[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Fortran on WebAssembly\n\n\n\n\n\n\nhacks\n\n\nwasm\n\n\nfortran\n\n\nprogramming\n\n\n\nPatching LLVM Flang to output WebAssembly objects.\n\n\n\n\n\nMar 12, 2024\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nWebR 0.2.0 has been released\n\n\n\n\n\n\nprogramming\n\n\nr\n\n\nwasm\n\n\nwebr\n\n\n\nWebR 0.2.0 has been released. Updates and improvements to the webR REPL app, HTML canvas graphics device, internationalisation, Wasm R packages, Shiny support, and the developer API.\n\n\n\n\n\nAug 16, 2023\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nWebR 0.1.0 has been released\n\n\n\n\n\n\nprogramming\n\n\nr\n\n\nwasm\n\n\nwebr\n\n\n\nWebR 0.1.0 has been released! Using the magic of WebAssembly, webR allows you to run R code directly within a web browser.\n\n\n\n\n\nMar 9, 2023\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nAn R grammar experiment\n\n\n\n\n\n\nhacks\n\n\nr\n\n\nprogramming\n\n\n\nHacking at R’s grammar so as to allow for JSX-style XML tags.\n\n\n\n\n\nFeb 7, 2023\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nDIY FM synthesiser\n\n\n\n\n\n\nprogramming\n\n\naudio\n\n\nhardware\n\n\n\nBuilding a DIY FM synthesiser, based on an Yamaha OPL2 and electronic audio kit.\n\n\n\n\n\nJun 22, 2022\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nForth on a calculator\n\n\n\n\n\n\nhacks\n\n\nretro\n\n\nhardware\n\n\nprogramming\n\n\n\nHacking a Casio CFX-9850G calculator to run custom machine code.\n\n\n\n\n\nApr 3, 2022\n\n\nGeorge Stagg\n\n\n\n\n\n\n\n\n\n\n\n\nHyperbolic fractals\n\n\n\n\n\n\nmaths\n\n\nwebgl\n\n\n\nThe Mandelbrot Set living on a Poincaré disc.\n\n\n\n\n\nJun 27, 2021\n\n\nGeorge Stagg\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "education.html",
    "href": "education.html",
    "title": "Education",
    "section": "",
    "text": "Newcastle University\nThesis: A Numerical Study of Vortices and Turbulence in Quantum Fluids\nSupervisors: Prof. Carlo Barenghi & Prof. Nick Parker\n\n\n\nNewcastle University\nDissertation: The Movement of a Fractal Through a Bose-Einstein Condensate\nSupervisor: Prof. Carlo Barenghi"
  },
  {
    "objectID": "education.html#qualifications",
    "href": "education.html#qualifications",
    "title": "Education",
    "section": "",
    "text": "Newcastle University\nThesis: A Numerical Study of Vortices and Turbulence in Quantum Fluids\nSupervisors: Prof. Carlo Barenghi & Prof. Nick Parker\n\n\n\nNewcastle University\nDissertation: The Movement of a Fractal Through a Bose-Einstein Condensate\nSupervisor: Prof. Carlo Barenghi"
  },
  {
    "objectID": "education.html#teaching-experience",
    "href": "education.html#teaching-experience",
    "title": "Education",
    "section": "Teaching Experience",
    "text": "Teaching Experience\n\nNewcastle University — School of Mathematics & Statistics\n\nPHY1030: Introduction to Python for Laboratory Physics (2020–2022)\nMAS2502: Introduction to Computing and Problem Solving (2018–2020)\nMathematical Typesetting with \\(\\mathrm\\LaTeX\\) (2016–2021)\nIntroduction to R & MATLAB (2016–2021)\nIntroduction to Linux (2018–2020)"
  },
  {
    "objectID": "education.html#research-experience",
    "href": "education.html#research-experience",
    "title": "Education",
    "section": "Research Experience",
    "text": "Research Experience\n\nTheoretical Physics\n\nSuperfluidity & quantum turbulence\nVortex fluid dynamics\nUltra-cold gasses & Bose-Einstein condensation\n\n\n\nComputational Mathematics\n\nDiscrete graph curvature\nFinite-characteristic Lie algebras\n\n\n\nResearch Software Engineering\n\nHPC software engineering & system administration\nLarge scale parallel computing with MPI & OpenMP\nAuthenticaiton management with Kerberos & SSSD\nStorage server management (CIFS/NFS) using Illumos & ZFS\n\n\n\nDigital Learning\n\nAssessment in the mathematical sciences\nEffective computing & software pedagogy\nWeb content delivery & accessibility for mathematical sciences"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dr George W Stagg",
    "section": "",
    "text": "Senior Software Engineer @ Posit Software, PBC.\nLead Developer of the webR project."
  },
  {
    "objectID": "posts/fortran_wasm/index.html",
    "href": "posts/fortran_wasm/index.html",
    "title": "Fortran on WebAssembly",
    "section": "",
    "text": "Thumbnail by Mike Hindle."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#compiler-round-up",
    "href": "posts/fortran_wasm/index.html#compiler-round-up",
    "title": "Fortran on WebAssembly",
    "section": "Compiler round-up",
    "text": "Compiler round-up\nSince FORTRAN in the Browser was published things have changed a little, particularly when it comes to the LLVM-based Fortran compilers. As far as I am aware, here’s a brief round-up of the current situation in 2024.\n\nThe f2c utility\nThe f2c program converts Fortran 77 to C code, which Emscripten can then compile into WebAssembly. This is the method that the Pyodide project uses to compile Python packages containing Fortran code. They say that this “does not work very well”. The tool doesn’t work with modern Fortran code, and even after conversion the result still throws fatal errors and requires extensive patching.\n\n\nLFortran\nThe LFortran compiler has made great strides over the last few years. In 2020, it was missing basic features such as loops, conditionals, and variable assignment. It now supports a much wider range of language features and can be used to compile a reasonable amount of Fortran code. It can even compile to WebAssembly out of the box!8\n8 Check out the LFortran demo at https://dev.lfortran.org. While extremely impressive, note that the first thing I tried was changing x ** 2 to x ** 3 and saw that such a change is currently not supported by the code generator.However, there are still some barriers that make using LFortran a little rough. The project is currently considered to be in alpha phase and the developers state that issues compiling real-world code are expected. While it can successfully compile some projects, such as MINPACK, the full Fortran specification is not yet supported and so many larger projects still cannot be compiled.\nThe LFortran developers are targeting full support for Fortran 2018, and its standout feature is an interactive Jupyter-like Fortran REPL. With a few more years of development, I expect that LFortran will be an excellent choice for compiling Fortran code for WebAssembly.\n\n\nDragonegg\nDragonegg is a plugin for GCC that uses the GNU compilers as a frontend and emits LLVM IR. With this, LLVM can be used as the backend to produce WebAssembly output. The technique works, and it was the original method that I used to compile Fortran sources for the webR project.\nHowever, there are some pretty serious drawbacks to this approach. Dragonegg requires a very old version of GCC and LLVM9. For most users, this means setting up a virtual machine or Docker container to provide the necessary environment. The LLVM IR emitted by Dragonegg also needs some fairly nasty post-processing before LLVM can produce WebAssembly output. Take a look at the script originally used by webR to get an idea of the extra processing required.\n9 The latest supported versions are gcc-4.8 and llvm-3.3Nevertheless, in 2020 this was the only real way to compile Fortran code for WebAssembly.\n\n\nClassic flang\n“Classic” Flang10 is another Fortran compiler targeting LLVM, based on an open-sourced PGI/NVIDIA compiler pgfortran. Classic Flang never supported 32-bit output, so it is not an option for us since we’ll be using wasm32 for our target architecture. This will likely be the case until browser support for 64-bit Wasm memory has improved11.\n10 Previously, Flang or Flang-7.11 At the time of writing Firefox, Chrome and Node supports wasm64, but locked behind a feature flag.Even so, the project documentation itself suggests that choosing to use Classic Flang for a new project today is probably not a great idea:\n\nClassic Flang […] continues to be maintained, but the plan is to replace Classic Flang with the new Flang in the future.\n\n\n\nLLVM Flang\n“LLVM Flang”12 is a full ground-up reimplementation of a Fortran frontend for LLVM. It was designed to replace Classic Flang, developed by much of the same team, and was accepted as part of the LLVM project as of LLVM 11. As such, the Flang sources can now be found in the official LLVM source tree.\n12 Also known as Flang, new Flang, or flang-new. Previously, F18.Flang is not yet considered to be ready for production use, but its development is extremely active right now and pre-production versions of the flang-new compiler have been made available by the team. In recent years, the compiler has become very usable for compiling real-world Fortran code.\nCurrently, LLVM Flang cannot generate WebAssembly output out of the box. Despite this, we’ll soon see that with LLVM’s modular design it’s possible to use the Flang frontend with LLVM’s WebAssembly backend. With this, we can take advantage of all the development work put into the Flang frontend by the NVIDIA and PGI teams for our own purposes of compiling Fortran to WebAssembly.\nThis was also possible back in 2020, though it required larger patches to LLVM, injecting custom maths routines, and a multi-step compilation process. Now, due to the impressive development efforts in the flang-new frontend, creating a Fortran to WebAssembly compiler is possible with just a few small changes to LLVM’s source code."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#interlude-calling-fortran-subroutines-from-c",
    "href": "posts/fortran_wasm/index.html#interlude-calling-fortran-subroutines-from-c",
    "title": "Fortran on WebAssembly",
    "section": "Interlude — Calling Fortran subroutines from C",
    "text": "Interlude — Calling Fortran subroutines from C\nWhile we wait for LLVM to build, start up a new terminal and we’ll remind ourselves how to compile and link a Fortran subroutine as part of a C program. The principles here will help us later when it comes to calling Fortran from JavaScript.\nFirst, let’s write a simple subroutine that takes in three integer arguments: x, y, and z. It will set the value of z to the sum of x and y. Name our new subroutine foo and save the file containing your subroutine as foo.f08.\n\n\nfoo.f08\n\nSUBROUTINE foo(x, y, z)\n    IMPLICIT NONE\n    INTEGER, INTENT(IN)  :: x, y\n    INTEGER, INTENT(OUT) :: z\n    z = x + y\nEND\n\nNotice how, generally, Fortran routines pass arguments by reference and we can declare how an argument will be used in the subroutine using INTENT(). Assuming you already have a traditional Fortran compiler like gfortran installed16, compile the Fortran source into an object file.\n16 You don’t need a native fortran compiler to follow along with the rest of the post, but if you’d like one you can get gfortran from your OS’s usual package manager as part of the GCC compiler suite. There’s also ifort, if you’re on an Intel CPU.\n[~/fortran]gfortran -c foo.f08 -o foo.o\n[~/fortran]file foo.o\nfoo.o: Mach-O 64-bit object arm64\n[~/fortran]nm foo.o\n0000000000000038 s EH_frame1\n0000000000000000 T _foo_\n0000000000000000 t ltmp0\n0000000000000038 s ltmp1\n\nI’m on an M1 macOS machine, so my resulting object is a Mach object for ARM. If you’re a Linux user, you should see something like ELF 64-bit LSB shared object, x86-64. I’ve also run nm to take a look at the names of the symbols in the object that the compiler has built. Keep an eye on the symbol for our subroutine — on my machine it’s named _foo_. The leading underscore is fairly standard, but the trailing underscore differs from what is usual for C procedures.\nLet’s write a C program that calls our Fortran subroutine17. Notice again how we pass the arguments by reference to the external symbol. Also, if your Fortran compiler added the trailing underscore, we’ll need to include it when we declare the symbol name in C.\n17 Modern Fortran standards provide a Fortran module iso_c_binding and a C header file ISO_Fortran_binding.h to improve C interoperability, but our code is going to be simple enough that we can do without those today.\n\nmain.c\n\n#include &lt;stdio.h&gt;\n\nextern void foo_(int*, int*, int*);\n\nint main() {\n    int x = 1, y = 1, z;\n    foo_(&x, &y, &z);\n\n    printf(\"%d + %d = %d\\n\", x, y, z);\n    return 0;\n}\n\nCompile the C source using gcc or equivalent, and then run the resulting binary to observe a truly staggering level of numerical computation.\n\n[~/fortran]gcc main.c foo.o -o main\n[~/fortran]./main\n1 + 1 = 2"
  },
  {
    "objectID": "posts/fortran_wasm/index.html#returning-to-llvm-flang",
    "href": "posts/fortran_wasm/index.html#returning-to-llvm-flang",
    "title": "Fortran on WebAssembly",
    "section": "Returning to LLVM Flang",
    "text": "Returning to LLVM Flang\nOnce LLVM has finished compiling, the flang-new binary should be available in the directory build/bin. We can now run it and confirm that it has been set up to produce binaries for wasm32 and Emscripten.\n\n[~/fortran]./build/bin/flang-new --version\nflang-new version 18.1.1 (https://github.com/llvm/llvm-project.git dba2a75e9c7ef81fe84774ba5eee5e67e01d801a)\nTarget: wasm32-unknown-emscripten\nThread model: posix\nInstalledDir: .../fortran/build/bin\n\nGreat! Let’s try compiling our Fortran subroutine using our freshly built compiler.\n\n[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o\nerror: fortran/llvm-project/flang/lib/Optimizer/CodeGen/Target.cpp:1162:\nnot yet implemented: target not implemented\nLLVM ERROR: aborting\n\nAh, not so great. The wasm32-unknown-emscripten target triple unfortunately hasn’t been implemented yet in the flang-new compiler.\nAnd so here comes our first patch to LLVM. We will implement the target by extending Flang’s list of known target specifics. The required changes, shown below as a diff, can be mostly deduced by looking at the other targets implemented in the file flang/lib/Optimizer/CodeGen/Target.cpp.\ndiff --git a/flang/lib/Optimizer/CodeGen/Target.cpp b/flang/lib/Optimizer/CodeGen/Target.cpp\nindex 83e7fa9b440b..49e73ec48e0a 100644\n--- a/flang/lib/Optimizer/CodeGen/Target.cpp\n+++ b/flang/lib/Optimizer/CodeGen/Target.cpp\n@@ -1109,6 +1109,44 @@ struct TargetLoongArch64 : public GenericTarget&lt;TargetLoongArch64&gt; {\n };\n } // namespace\n \n+//===----------------------------------------------------------------------===//\n+// WebAssembly (wasm32) target specifics.\n+//===----------------------------------------------------------------------===//\n+\n+namespace {\n+struct TargetWasm32 : public GenericTarget&lt;TargetWasm32&gt; {\n+  using GenericTarget::GenericTarget;\n+\n+  static constexpr int defaultWidth = 32;\n+\n+  CodeGenSpecifics::Marshalling\n+  complexArgumentType(mlir::Location, mlir::Type eleTy) const override {\n+    assert(fir::isa_real(eleTy));\n+    CodeGenSpecifics::Marshalling marshal;\n+    // Use a type that will be translated into LLVM as:\n+    // { t, t }   struct of 2 eleTy, byval, align 4\n+    auto structTy =\n+        mlir::TupleType::get(eleTy.getContext(), mlir::TypeRange{eleTy, eleTy});\n+    marshal.emplace_back(fir::ReferenceType::get(structTy),\n+                         AT{/*alignment=*/4, /*byval=*/true});\n+    return marshal;\n+  }\n+\n+  CodeGenSpecifics::Marshalling\n+  complexReturnType(mlir::Location loc, mlir::Type eleTy) const override {\n+    assert(fir::isa_real(eleTy));\n+    CodeGenSpecifics::Marshalling marshal;\n+    // Use a type that will be translated into LLVM as:\n+    // { t, t }   struct of 2 eleTy, sret, align 4\n+    auto structTy = mlir::TupleType::get(eleTy.getContext(),\n+                                          mlir::TypeRange{eleTy, eleTy});\n+    marshal.emplace_back(fir::ReferenceType::get(structTy),\n+                          AT{/*alignment=*/4, /*byval=*/false, /*sret=*/true});\n+    return marshal;\n+  }\n+};\n+} // namespace\n+\n // Instantiate the overloaded target instance based on the triple value.\n // TODO: Add other targets to this file as needed.\n std::unique_ptr&lt;fir::CodeGenSpecifics&gt;\n@@ -1158,6 +1196,9 @@ fir::CodeGenSpecifics::get(mlir::MLIRContext *ctx, llvm::Triple &&trp,\n   case llvm::Triple::ArchType::loongarch64:\n     return std::make_unique&lt;TargetLoongArch64&gt;(ctx, std::move(trp),\n                                                std::move(kindMap), dl);\n+  case llvm::Triple::ArchType::wasm32:\n+    return std::make_unique&lt;TargetWasm32&gt;(ctx, std::move(trp),\n+                                               std::move(kindMap), dl);\n   }\n   TODO(mlir::UnknownLoc::get(ctx), \"target not implemented\");\n }\nSave the contents of the above diff as the file add-wasm32-target.diff, and then apply it to the llvm-project directory using git or the patch utility. Then, rebuild LLVM Flang. It should be quicker to build the second time, as most generated objects are unaffected by the change.\n\n[~/fortran]patch -p1 -d llvm-project &lt; add-wasm32-target.diff\n[~/fortran]cmake --build build\n...\n[180/180] Generating ../../../../include/flang/ieee_arithmetic.mod\n\nOnce LLVM has been recompiled, try compiling our Fortran source once again.\n\n[~/fortran]./build/bin/flang-new -c foo.f08 -o foo.o\n[~/fortran]file foo.o\nfoo.o: WebAssembly (wasm) binary module version 0x1 (MVP)\n[~/fortran]llvm-nm foo.o\n00000001 T foo_\n\nSuccess! We can confirm this is a real WebAssembly object using the file utility, and llvm-nm18 can see the foo symbol within, corresponding to our Fortran subroutine.\n18 You might need to use a WebAssembly aware version of this tool from Emscripten. If you’re using emsdk, ensure that .../emsdk/upstream/bin/ is on your $PATH.19 Here I’m using Node v18, but I think anything newer than Node v16 should work. Emscripten is bundled with a version of Node, but I like using nvm to manage my Node installations.Let’s continue compiling our C function for WebAssembly using Emscripten and running it using Node19. We should see the same output as with our native binary.\n\n[~/fortran]emcc main.c foo.o -o main.js\n[~/fortran]node main.js\n1 + 1 = 2"
  },
  {
    "objectID": "posts/fortran_wasm/index.html#interlude-calling-a-fortran-routine-from-javascript",
    "href": "posts/fortran_wasm/index.html#interlude-calling-a-fortran-routine-from-javascript",
    "title": "Fortran on WebAssembly",
    "section": "Interlude — Calling a Fortran routine from JavaScript",
    "text": "Interlude — Calling a Fortran routine from JavaScript\nIn the previous section we used a C program to call Fortran code, but we don’t technically need to do that. If we tell Emscripten about the Fortran subroutine, we can call it directly from JavaScript without writing any C code.\nFirst, let’s link our Fortran object with Emscripten, producing a script that loads our WebAssembly binary into memory but does not execute any routines. In addition to our symbol _foo_, we’ll also export _malloc and _free so that we can use them from JavaScript20.\n20 See the Emscripten documentation for more details about emcc command line options. By the way, if you’ve not used Emscripten much before you might see extra cache:INFO lines emitted during various steps in this post. They are nothing to worry about and can be ignored.\n[~/fortran]emcc foo.o -sEXPORTED_FUNCTIONS=_foo_,_malloc,_free -o foo.js\ncache:INFO: generating system asset: symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json... (this will be cached in \".../emsdk/upstream/emscripten/cache/symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json\" for subsequent builds)\ncache:INFO:  - ok\n[~/fortran]node foo.js\n[~/fortran]\n\nNotice that when we run the script foo.js directly… nothing happens.\nNext, we’ll write a JavaScript file that loads foo.js and then calls our Fortran subroutine. We’ll need to allocate some memory to hold our integers x, y and z using the exported _malloc() function. We’ll also need to set our input arguments x and y to some integer values, and we can do that by setting values in the allocated WebAssembly memory through Module.HEAPU3221.\n21 Alternatively, see the setValue() and getValue() functions in the Emscripten API.\n\nstandalone.js\n\nvar Module = require('./foo.js');\n\nsetTimeout(() =&gt; {\n  const x = Module._malloc(4);\n  const y = Module._malloc(4);\n  const z = Module._malloc(4);\n  Module.HEAPU32[x / 4] = 123;\n  Module.HEAPU32[y / 4] = 456;\n\n  Module._foo_(x, y, z);\n\n  console.log(\"x = \", Module.HEAP32[x / 4]);\n  console.log(\"y = \", Module.HEAP32[y / 4]);\n  console.log(\"x + y = \", Module.HEAP32[z / 4]);\n\n  Module._free(x);\n  Module._free(y);\n  Module._free(z);\n}, 100);\n\n\n[~/fortran]node standalone.js\nx =  123\ny =  456\nx + y =  579\n\nYou should also be able to run the resulting WebAssembly binary in a web browser. Remove the line var Module = require('./foo.js'); from standalone.js, and instead load the script foo.js in your HTML.\n\n\nindex.html\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Fortran Demo&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=\"foo.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"standalone.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\nSpin up a local web server22, visit the page, and the same output should be seen in the browser’s JavaScript console.\n22 Something like Rscript -e 'httpuv::runStaticServer()' or python3 -m http.server should work well."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#the-fortran-runtime-library-a-journey-to-hello-world",
    "href": "posts/fortran_wasm/index.html#the-fortran-runtime-library-a-journey-to-hello-world",
    "title": "Fortran on WebAssembly",
    "section": "The Fortran runtime library: A journey to “Hello, World!”",
    "text": "The Fortran runtime library: A journey to “Hello, World!”\nThe ubiquitous “Hello, World!” test program is the usual way to introduce a programming language, but I didn’t introduce Fortran using such a program above. As you’ll see, that was for a good reason. Let’s see what happens when we try to build a “Hello, World!” subroutine in Fortran and call it from C. As before, we’ll compile the Fortran object using flang-new and use Emscripten to compile and link the C code.\n\n\nhello.f08\n\nSUBROUTINE hello()\n    IMPLICIT NONE\n    PRINT *, \"Hello, World!\"\nEND\n\n\n\nhello.c\n\nextern void hello_();\n\nint main() {\n    hello_();\n    return 0;\n}\n\n\n[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o\n[~/fortran]emcc hello.c hello.o -o hello.js\nwasm-ld: error: hello.o: undefined symbol: _FortranAioBeginExternalListOutput\nwasm-ld: error: hello.o: undefined symbol: _FortranAioOutputAscii\nwasm-ld: error: hello.o: undefined symbol: _FortranAioEndIoStatement\nemcc: error: 'wasm-ld -o hello.wasm [...] --no-entry --stack-first --table-base=1' failed (returned 1)\n\nThe build failed due to some missing symbols. This is a consequence of a more general issue in that we have not yet compiled the LLVM Fortran runtime library for WebAssembly. There are a bunch of library symbols that we’re currently missing, including some functions that are required to print output!23\n23 See LLVM Flang’s documentation for the nuts and bolts of the Fortran IO runtime library implementation.Luckily, the runtime library is written in C++ as part of the LLVM source tree at llvm-project/flang/runtime. So, in principle, all we need to do is build the library using Emscripten’s em++ compiler and then link to it whenever we’re using Fortran code in our WebAssembly program.\nHere is a Makefile designed to make this step easy. Save it24 in the current directory and then run make. It should go ahead and use the version of Emscripten on your path to build a static Fortran runtime library at build/flang/runtime/libFortranRuntime.a.\n24 Be sure to indent the rules in this file using tabs, not spaces.\n\nMakefile\n\nROOT = $(abspath .)\nSOURCE = $(ROOT)/llvm-project\nBUILD = $(ROOT)/build\n\nRUNTIME_SOURCES := $(wildcard $(SOURCE)/flang/runtime/*.cpp)\nRUNTIME_SOURCES += $(SOURCE)/flang/lib/Decimal/decimal-to-binary.cpp\nRUNTIME_SOURCES += $(SOURCE)/flang/lib/Decimal/binary-to-decimal.cpp\nRUNTIME_OBJECTS = $(patsubst $(SOURCE)/%,$(BUILD)/%,$(RUNTIME_SOURCES:.cpp=.o))\n\nRUNTIME_CXXFLAGS += -I$(BUILD)/include -I$(BUILD)/tools/flang/runtime\nRUNTIME_CXXFLAGS += -I$(SOURCE)/flang/include -I$(SOURCE)/llvm/include\nRUNTIME_CXXFLAGS += -DFLANG_LITTLE_ENDIAN\nRUNTIME_CXXFLAGS += -fPIC -Wno-c++11-narrowing -fvisibility=hidden\nRUNTIME_CXXFLAGS += -DFE_UNDERFLOW=0 -DFE_OVERFLOW=0 -DFE_INEXACT=0\nRUNTIME_CXXFLAGS += -DFE_INVALID=0 -DFE_DIVBYZERO=0 -DFE_ALL_EXCEPT=0\n\n$(BUILD)/flang/runtime/libFortranRuntime.a: $(RUNTIME_OBJECTS)\n    @rm -f $@\n    emar -rcs $@ $^\n\n$(BUILD)%.o : $(SOURCE)%.cpp\n    @mkdir -p $(@D)\n    em++ $(RUNTIME_CXXFLAGS) -o $@ -c $&lt;\n\n.PHONY: clean\nclean:\n    @rm $(RUNTIME_OBJECTS) $(BUILD)/flang/runtime/libFortranRuntime.a\n\n\n[~/fortran]make\nem++ .../ISO_Fortran_binding.o -c .../ISO_Fortran_binding.cpp\nem++ .../allocatable.o -c .../allocatable.cpp\nem++ .../array-constructor.o -c .../array-constructor.cpp\n...\nemar -rcs build/flang/runtime/libFortranRuntime.a .../binary-to-decimal.o\n[~/fortran]file build/flang/runtime/libFortranRuntime.a\nbuild/flang/runtime/libFortranRuntime.a: current ar archive\n\nLet’s try again, linking in our shiny new library as part of the Emscripten build step.\n\n[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o\n[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o hello.js\nwasm-ld: warning: function signature mismatch: _FortranAioOutputAscii\n&gt;&gt;&gt; defined as (i32, i32, i64) -&gt; i32 in hello.o\n&gt;&gt;&gt; defined as (i32, i32, i32) -&gt; i32 in build/flang/runtime/libFortranRuntime.a(io-api.o)\n\nSuccess? Not quite. A warning is issued, letting us know about a signature mismatch. Emscripten has compiled the symbol _FortranAioOutputAscii to take three i32 arguments25. However, flang-new has compiled hello.f08 with the expectation that the symbol takes two i32 arguments and a single i64 argument.\n25 This is LLVM IR notation, meaning an integer of size 32 bits.26 This continues to crop up when compiling R packages for webR. Package authors or vendored libraries may have used tools such as f2c that declare a Fortran SUBROUTINE to return an int, while other libraries might declare a Fortran SUBROUTINE to return void. Who is right? I’m not sure, as I understand it early Fortran did not have a standard interface to C. Personally, I think returning void makes most sense.This is unfortunate. Despite being emitted as just a warning, if you try running the emitted program using Node you will see that the problem is catastrophic. WebAssembly, unlike a lot of target systems, absolutely requires that symbols defined over multiple compilation units have consistent function signatures, both in argument and return type26.\n\n[~/fortran]node hello.js\n.../fortran/hello.js:128\n    throw ex;\n    ^\nRuntimeError: unreachable\n  at wasm://wasm/001a0366:wasm-function[20]:0x15d9\n  at removeRunDependency (/Users/georgestagg/fortran/hello.js:630:7)\n\nNode.js v18.18.0\n\nRather than going over the debugging process that eventually leads us to what is going on here, let me point you directly to the cause of the problem. Take a look at this comment from the LLVM source:\n\n\nflang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n\n//===----------------------------------------------------------------------===//\n// Type builder models\n//===----------------------------------------------------------------------===//\n\n// TODO: all usages of sizeof in this file assume build ==  host == target.\n// This will need to be re-visited for cross compilation.\n\n/// Return a function that returns the type signature model for the type `T`\n/// when provided an MLIRContext*. This allows one to translate C(++) function\n/// signatures from runtime header files to MLIR signatures into a static table\n/// at compile-time.\n///\n/// For example, when `T` is `int`, return a function that returns the MLIR\n/// standard type `i32` when `sizeof(int)` is 4.\n\nAnd therein lies the problem. For us, the host is different to the target, breaking assumptions in the LLVM source code. Surprisingly, this does not cause as much chaos as you might expect. From what I can tell, this machinery is used only to make the Fortran runtime library functions, written in C++, available to Fortran. There is a compile-time calculation using sizeof(), and since most of the sizes match anyway27 it mostly works fine.\n27 The C data model for the host and target defines how many bits certain fundamental C types are represented with. The specific sizes can differ based on the hardware architecture and your OS.Unfortunately for us, assuming you’re following along on a modern 64-bit Unix-like system such as Linux or macOS, the sizes don’t match for the long data type. The result of sizeof(long) on our compiler’s host platform is 8 bytes (i64), but for the target platform of wasm32-unknown-emscripten the returned value should be 4 bytes (i32).\nWhen we compile the Fortran runtime library C++ code using Emscripten, things are fine. The resulting symbols are compiled with signatures such that long arguments are i32. However, when we compile our Fortran code with flang-new the external library symbols are declared such that long arguments are i64. This difference leads to the inconsistent function signature warning and runtime failure.\nWhy did using PRINT() in our “Hello, World!” program invoke a function that takes an argument of type long? Well, in some implementations of Fortran there are so-called “hidden” arguments that are added whenever you pass a Fortran CHARACTER type to a function or subroutine. These extra arguments pass in the length of the strings. In the Fortran runtime library the hidden arguments are declared with type size_t which, following a chain of typedefs, ends up being the same as unsigned long. This hidden implicit argument is the one with inconsistent size."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#hacking-around-the-issue",
    "href": "posts/fortran_wasm/index.html#hacking-around-the-issue",
    "title": "Fortran on WebAssembly",
    "section": "Hacking around the issue",
    "text": "Hacking around the issue\nUnfortunately, I don’t know enough about the LLVM or Flang internals to implement a real solution to this problem. Ideally, flang-new would emit the correct use of i32 or i64 for the target architecture and data model when cross-compiling, no matter the host architecture the compiler is running on.\nSince I can’t solve this today, let’s hack around it for now. We’ll build a version of flang-new with the size of a long hard-coded to what we need for wasm32 and Emscripten. We’ll also make some changes so that calls to malloc() from Fortran are emitted with an i32 argument28.\n28 This additionally fixes dynamic allocation with ALLOCATE(), a feature introduced in Fortran 90.The required patches are again shown as a diff below. If you’re following along, save it as a file named force-4-byte-values.diff and apply it to the llvm-project directory using git or the patch utility. Finally, recompile flang-new once more.\n\n\nforce-4-byte-values.diff\n\ndiff --git a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\nindex b3fe52f4b..c3c7326da 100644\n--- a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n+++ b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h\n@@ -146,7 +146,7 @@ constexpr TypeBuilderFunc getModel&lt;void **&gt;() {\n template &lt;&gt;\n constexpr TypeBuilderFunc getModel&lt;long&gt;() {\n   return [](mlir::MLIRContext *context) -&gt; mlir::Type {\n-    return mlir::IntegerType::get(context, 8 * sizeof(long));\n+    return mlir::IntegerType::get(context, 8 * 4);\n   };\n }\n template &lt;&gt;\n@@ -187,7 +187,7 @@ constexpr TypeBuilderFunc getModel&lt;long long *&gt;() {\n template &lt;&gt;\n constexpr TypeBuilderFunc getModel&lt;unsigned long&gt;() {\n   return [](mlir::MLIRContext *context) -&gt; mlir::Type {\n-    return mlir::IntegerType::get(context, 8 * sizeof(unsigned long));\n+    return mlir::IntegerType::get(context, 8 * 4);\n   };\n }\n template &lt;&gt;\ndiff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp\nindex ba5946415..2931753a8 100644\n--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp\n+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp\n@@ -1225,7 +1225,7 @@ getMalloc(fir::AllocMemOp op, mlir::ConversionPatternRewriter &rewriter) {\n     return mlir::SymbolRefAttr::get(userMalloc);\n   mlir::OpBuilder moduleBuilder(\n       op-&gt;getParentOfType&lt;mlir::ModuleOp&gt;().getBodyRegion());\n-  auto indexType = mlir::IntegerType::get(op.getContext(), 64);\n+  auto indexType = mlir::IntegerType::get(op.getContext(), 32);\n   auto mallocDecl = moduleBuilder.create&lt;mlir::LLVM::LLVMFuncOp&gt;(\n       op.getLoc(), mallocName,\n       mlir::LLVM::LLVMFunctionType::get(getLlvmPtrType(op.getContext()),\n@@ -1281,6 +1281,7 @@ struct AllocMemOpConversion : public FIROpConversion&lt;fir::AllocMemOp&gt; {\n     mlir::Type heapTy = heap.getType();\n     mlir::Location loc = heap.getLoc();\n     auto ity = lowerTy().indexType();\n+    auto i32ty = mlir::IntegerType::get(rewriter.getContext(), 32);\n     mlir::Type dataTy = fir::unwrapRefType(heapTy);\n     mlir::Type llvmObjectTy = convertObjectType(dataTy);\n     if (fir::isRecordWithTypeParameters(fir::unwrapSequenceType(dataTy)))\n@@ -1291,9 +1292,10 @@ struct AllocMemOpConversion : public FIROpConversion&lt;fir::AllocMemOp&gt; {\n     for (mlir::Value opnd : adaptor.getOperands())\n       size = rewriter.create&lt;mlir::LLVM::MulOp&gt;(\n           loc, ity, size, integerCast(loc, rewriter, ity, opnd));\n+    auto size_i32 = integerCast(loc, rewriter, i32ty, size);\n     heap-&gt;setAttr(\"callee\", getMalloc(heap, rewriter));\n     rewriter.replaceOpWithNewOp&lt;mlir::LLVM::CallOp&gt;(\n-        heap, ::getLlvmPtrType(heap.getContext()), size, heap-&gt;getAttrs());\n+        heap, ::getLlvmPtrType(heap.getContext()), size_i32, heap-&gt;getAttrs());\n     return mlir::success();\n   }\n\n\n[~/fortran]patch -p1 -d llvm-project &lt; force-4-byte-values.diff\n[~/fortran]cmake --build build\n[0/60] Building CXX object tools/flang/lib/Lower/Runtime.cpp.o\n...\n[49/49] Generating ../../../../include/flang/ieee_arithmetic.f18.mod\n\nOnce LLVM has been rebuilt, try compiling our program once again. This time, it should compile without any warnings and successfully run under Node:\n\n[~/fortran]./build/bin/flang-new -c hello.f08 -o hello.o\n[~/fortran]emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o hello.js[~/fortran]node hello.js\n Hello, World!"
  },
  {
    "objectID": "posts/fortran_wasm/index.html#mnist",
    "href": "posts/fortran_wasm/index.html#mnist",
    "title": "Fortran on WebAssembly",
    "section": "Example: A handwritten digit classifier",
    "text": "Example: A handwritten digit classifier\nThe following demo uses a multi-layer perceptron (MLP) artificial neural network to classify hand-drawn digits. Try it out with your mouse or touchscreen! Just draw a digit from 0-9 in the box, and the classifier will try to label what digit you wrote. The relative probabilities according to the network are shown in a plot on the right.\n\n\n\nIt’s not a perfect model, but it works fairly well for me! The weights powering the model have been pre-trained using Python, but the classification is performed at runtime using JavaScript and WebAssembly, running in your browser right now.\nWith an MLP network, the classification process is essentially a repeated application of matrix-vector addition and multiplication. In this demo the heavy lifting is done by a single Fortran subroutine making use of the BLAS level 2 routine DGEMV()."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#building-lapack",
    "href": "posts/fortran_wasm/index.html#building-lapack",
    "title": "Fortran on WebAssembly",
    "section": "Building LAPACK",
    "text": "Building LAPACK\nLAPACK (Linear Algebra Package) is a software library for solving linear algebra problems numerically. It’s built upon BLAS and has similarly become a standard with many reimplementations designed for specific hardware or systems.\nLet’s finish this post by also building the “reference implementation” of LAPACK32.\n32 Also available from netlib, released under a modified BSD licence.\n[~/fortran]curl -L https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.0.tar.gz &gt; lapack-3.12.0.tgz\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 7747k    0 7747k    0     0  4117k      0 --:--:--  0:00:01 --:--:-- 6655k\n[~/fortran]tar xzf lapack-3.12.0.tgz\n\nSimilar to BLAS, we need to modify some configuration options to let LAPACK know about Emscripten and flang-new. Copy the file lapack-3.12.0/make.inc.example to lapack-3.12.0/make.inc, then make the following modifications. Be sure to replace [...] with the full path to the build directory on your machine33, and leave the other options in the file as they are.\n33 A relative path doesn’t work here. Alternatively, simply set the option to read flang-new and make it available on your $PATH.\n\nlapack-3.12.0/make.inc\n\nFC = [...]/build/bin/flang-new\nFFLAGS = -O2\nFFLAGS_DRV = $(FFLAGS)\nFFLAGS_NOOPT = -O0\n\nAR = emar\nRANLIB = emranlib\n\nTIMER = INT_CPU_TIME\n\nThen, build LAPACK using the make lib command to create the WebAssembly static library liblapack.a.\n\n[~/fortran]cd lapack-3.12.0\n[~/fortran/lapack-3.12.0]make lib\nmake -C SRC\n.../build/bin/flang-new -O2  -c -o sbdsvdx.o sbdsvdx.f\n...\nemar cr ../../libtmglib.a slatms.o ... dlarnd.o\nemranlib ../../libtmglib.a\n[~/fortran/lapack-3.12.0]cd ..\n[~/fortran]\n[~/fortran]file lapack-3.12.0/liblapack.a\nlapack-3.12.0/liblapack.a: current ar archive\n\nWith this, LAPACK routines can be called in a similar way to the BLAS routine example in the previous section."
  },
  {
    "objectID": "posts/fortran_wasm/index.html#example-polynomial-interpolation-with-linear-algebra",
    "href": "posts/fortran_wasm/index.html#example-polynomial-interpolation-with-linear-algebra",
    "title": "Fortran on WebAssembly",
    "section": "Example: Polynomial Interpolation with Linear Algebra",
    "text": "Example: Polynomial Interpolation with Linear Algebra\nThe following demo finds interpolating polynomials for a set of points, demonstrating LAPACK routines running in your web browser.\nClick the plot to add new points. An interpolating polynomial will be found to pass through all the points using Vandermonde’s method34. The linear algebra equation given by this method is then solved numerically in LAPACK using the DGELS() routine.\n34  It is always possible to find an \\(n-1\\) degree polynomial containing \\(n\\) data points exactly. However, when \\(n\\) is large the polynomial fluctuates wildly between successive data points. This problem is known as Runge’s phenomenon and can be avoided by using spline interpolation."
  },
  {
    "objectID": "posts/webr_released/index.html",
    "href": "posts/webr_released/index.html",
    "title": "WebR 0.1.0 has been released",
    "section": "",
    "text": "This post was originally published as an article on the Tidyverse Blog.\nWe’re super excited to announce the release of webR v0.1.0! This is the first release of webR intended for general use by the web development and R communities and is the result of almost a year of hard work by the webR developers.\nThis post will introduce webR, demonstrate some of the possibilities that running R in a web browser brings, and give a quick overview of how to include webR in your own TypeScript or JavaScript web applications."
  },
  {
    "objectID": "posts/webr_released/index.html#introduction",
    "href": "posts/webr_released/index.html#introduction",
    "title": "WebR 0.1.0 has been released",
    "section": "Introduction",
    "text": "Introduction\nWebR is a version of the open-source R interpreter compiled for WebAssembly, along with a supporting TypeScript library for interacting with the console and R objects from a JavaScript environment.\nBy compiling R to WebAssembly a user can visit a website and run R code directly within the web browser, without R installed on their device or a supporting computational R server. All that is required is a normal web server, including the type of cloud hosting service provided by Github Pages or Netlify."
  },
  {
    "objectID": "posts/webr_released/index.html#how-it-works",
    "href": "posts/webr_released/index.html#how-it-works",
    "title": "WebR 0.1.0 has been released",
    "section": "How it works",
    "text": "How it works\nWebR’s core is based around compiling the open-source R interpreter for WebAssembly, using the Emscripten compiler suite along with LLVM Flang to work with R’s pre-existing C and Fortran based source code.\nWebAssembly (often abbreviated as Wasm) is a standard defining a virtual stack machine along with a corresponding bytecode. Efficient Wasm engines have already been implemented in most modern web browsers, which allows for the deployment of high performance Wasm applications on the web.\nWhile it’s certainly possible for an interested programmer to write Wasm bytecode by hand, it is not a requirement to do so. Similar to how code and data is compiled into machine code for a certain computer processor, code and data can be compiled into the Wasm bytecode by compiler software that supports the Wasm standard.\nHowever, unlike with traditional machine code, the Wasm virtual machine (VM) is consistent across multiple different types of environment, architecture, and device – in theory the same bytecode binary can run anywhere without having to be recompiled for that environment. In this way the Wasm VM is similar to Java’s JVM. However, in comparison to the JVM, Wasm has been designed and built from the ground up for use on the modern web, requiring strict sandboxing and security controls.\nFuture use for WebAssembly has also been identified in server-side web development, containerisation, cloud computing, and more. With these applications, Wasm has been suggested as a universal binary format of the future. Multiple implementations of the Wasm VM already exist designed to run outside a web browser, through proposed Wasm standards such as WASI."
  },
  {
    "objectID": "posts/webr_released/index.html#whats-possible",
    "href": "posts/webr_released/index.html#whats-possible",
    "title": "WebR 0.1.0 has been released",
    "section": "What’s possible?",
    "text": "What’s possible?\nUndoubtedly, webR opens a world of possibilities for the interactive use of R and data science on the web.\n\nAn online R console\nA web-based interactive R console is included in the webR source repository as a demonstration of integrating webR into a wider web application. A publicly accessible instance of the webR console can be found at https://webr.r-wasm.org/latest/.\n\nWith the webR online console a new user can get up and running with R in seconds. The webR console is also functional on many modern mobile devices, where traditional versions of R are not always available for installation at all1.\n1 I am aware of at least one early adopter using webR as a way to access R on their Apple iPad.It’s possible to perform data analysis on reasonably large datasets by uploading data to a Virtual File System (VFS). The webR console provides an interface to view and interact with the VFS (Files tab, top right). Once a data file has been uploaded to the VFS it can be read by R like any standard file.\n\nNote that uploading and downloading files to the VFS in this way does not actually involve transferring any data over the network. However, webR has been built so that it is possible to load data into webR over the network by using R’s built in functions that can download from URL, such as read.csv()2.\n2 Note that there are some security measures in place when fetching data that are applied to all web applications. Downloading datasets from URL requires that the web server providing the data supports and allows Cross Origin Resource Sharing (CORS)\nPlotting is also supported (Plotting tab, top right), meaning a user can produce beautiful plot output with the webR console, closing the loop of reading data, performing analysis, and producing output. It is entirely feasible that a casual user could perform the basics of data science entirely within their web browser using webR.\n\n\nAn educational tool\nConsider the following code block containing some simple R code. After a short loading period while the webR binary and supporting files are downloaded, a Run code button is enabled on the code block, with the code itself able to be edited and remixed on the fly. Feel free to try this out now!\n\nLoading webR…\n\n\n\n\n\n\n\n\nAfter executing the R code once, try changing the am variable in the model to gear and then clicking Run code again. You should immediately see how changing the model affects the components of the resulting fit. There is a real R session running and powering this code block – try replacing the entire code with something new!\nThe following interactive code block produces an R plot that is directly embedded into the page. As with the previous example, the plot can be recreated or remixed multiple times by the reader simply by clicking the Run Code button.\n\nLoading webR…\n\n\n\n\n\n\n\n\nIn my experience this way of interacting and experimenting with R code without the mental overhead of context switching from a web browser to an R console, or copying and pasting lines of example code, feels extremely fresh and exciting. An exciting potential application for webR is providing high-quality educational web content in exactly this kind of format.\n\n\nReproducible reports\nA core principle of good science is that results should be repeatable and reproducible by others. Unfortunately the misuse of data analysis, leading to unreliable results, is a known issue.\nThe idea of a reproducible report is to bring the philosophy of repeatability to the delivery format itself. Reproducible reports weave together explanatory prose, data science, source code, output and figures; all in a single place with a consistent execution environment. With this, a user reading the report has everything they need to reproduce and confirm results for themselves.\nWhile Jupyter notebooks were not the first implementation of executable documents3, their popularity has grown over the last decade or so as a way to support high quality reproducible reports. Jupyter has been named “The data scientists’ computational notebook of choice” and almost 10 million Jupyter notebooks were publicly accessible on GitHub as of Oct 20204.\n3 Knuth originally introduced the precursor Literate Programming paradigm in 1984, and more recently tools such as Sweave, knitr and RMarkdown enable embedding R and computational results directly into a report.4 Admittedly, only a small proportion using an R kernel. The overwhelming majority use Python, R comes second, and Julia third.While a Jupyter notebook usually requires a Python and Jupyter installation to fully reproduce results, recent work by the JupyterLite team uses Wasm to bring Jupyter to the web browser. JupyterLite can be used with Pyodide to run Python based notebooks directly in the browser.\nWebR aims to provide that same experience for Jupyter notebooks based on R. As part of the initial release of webR, we are also releasing a webR kernel for JupyterLite, allowing users to write and execute reproducible Jupyter notebooks for R directly in the web browser.\nA JupyterLite instance with the webR kernel available can be found at https://jupyter.r-wasm.org/, along with a sample R Jupyter notebook demonstrating a reproducible report.\n\nThe JupyterLite kernel for R is still in the early stages of development and includes some limitations, but the core infrastructure is in place with the release of webR.\n\n\nR packages\nR has a rich history of user-created extensions through the use of R packages. Most packages are a combination of R and C or C++ code, and so many packages must be compiled from source for the system they are running on. Unfortunately, it is not possible to install packages in this way in webR. Such an installation process would require an entire C/C++ to WebAssembly compiler toolchain running in the web page!\nFor the moment, downloading pre-compiled Wasm binaries is the only supported way to install packages in webR. A pre-installed webr support package provides a helper function webr::install() which can be used to install packages from a CRAN-like repository. As part of the webR release we have provided a small repository of binary R packages compiled for Wasm, publicly hosted with URL https://repo.r-wasm.org/."
  },
  {
    "objectID": "posts/webr_released/index.html#using-webr-in-your-own-projects",
    "href": "posts/webr_released/index.html#using-webr-in-your-own-projects",
    "title": "WebR 0.1.0 has been released",
    "section": "Using webR in your own projects",
    "text": "Using webR in your own projects\nWebR aims to be as quick and easy to use as possible for those familiar with JavaScript web development. While a short introduction to using webR follows in this blog post, we think the best way to get up and running is by reading the Getting Started section of the webR documentation. The documentation goes into further detail about how to download webR, technical requirements for serving web pages that use webR, and provides more detailed examples.\n\nDownloading and using webR from npm\nFor a project with dependencies managed by npm, the webR JavaScript package can be installed by using the command,\nnpm i @r-wasm/webr\nOnce available, webR can be imported into a project and a new instance of webR initialised with,\nimport { WebR } from '@r-wasm/webr';\n\nconst webR = new WebR();\nawait webR.init();\nOnce a new instance of the WebR() class has been created, webR will begin to download WebAssembly binaries from the public CDN, and R will be started.\n\n\nDownloading webR release packages\nFull release packages for webR can also be downloaded from the webR GitHub Releases page. The full release packages include the webR JavaScript loader, along with WebAssembly binaries for R and its supporting libraries.\nHosting a full release package on a web server makes it possible to use webR entirely on your own infrastructure, rather than relying on downloading Wasm binaries from the public CDN.\n\n\nAn example of executing R code\nOnce R is ready, the JavaScript promise returned by webR.init() will resolve. At this point R code can be evaluated and results converted into JavaScript objects,\nlet result = await webR.evalR('rnorm(10,5,1)');\nlet output = await result.toArray();\nconsole.log(output);\nIn the above example the result object can be thought of as a reference to a specific R object, and is converted into a standard JavaScript array using the toArray() function.\nFurther examples and details of how to interact with the R console and work with R objects can be found in the webR documentation."
  },
  {
    "objectID": "posts/webr_released/index.html#the-future-of-webr",
    "href": "posts/webr_released/index.html#the-future-of-webr",
    "title": "WebR 0.1.0 has been released",
    "section": "The future of webR",
    "text": "The future of webR\nGoing forward we plan to expand and improve webR, including compiling more R packages for the webR public package repository. It is our hope that we can provide the same web-based computational infrastructure for R that Pyodide has provided for the Python ecosystem.\nWhile WebAssembly engines are in theory able to provide near-native performance, when it comes to the requirements for advanced data science or the deployment of sophisticated machine learning models, the benefits of running tools such as the RStudio IDE natively or a high-performance cloud deployment will likely always outperform the relatively restricted WebAssembly virtual machine. Despite this, webR can provide a smooth, interactive and immediate introduction to the world of working with data in R. Users who have not had the chance to use R in the past due to the barriers raised by the installation of new software to their workstation, or registration for a cloud-based service, might yet still be convinced to introduce R to their workflow though an introduction with interactive examples or short reports powered by webR.\nThe opportunity for enhancing educational content also continues beyond introductory materials. Many R packages are documented online, using automated tools such as pkgdown to produce a dedicated website for the package. Alongside an introductory description, package websites usually also include usage details in the form of example code, reference documentation, and vignette articles. However, if a potential user would like to try the package for themselves, often the only way is by installing the package onto their own machine. Immediately interactive examples, powered by webR, are an interesting future possibility that would reduce this kind of barrier to entry.\nFairly recently, the Shiny team announced Shiny for Python, a feature rich reactive web application framework targeting Python. Of particular note, the team used WebAssembly and Pyodide as a way to run a Shinylive server directly in the user’s web browser. One of the most exciting possible applications for webR is a similar architecture targeting the traditional R version of Shiny. Is it possible for a Shinylive for R to be powered by webR? We certainly hope so."
  },
  {
    "objectID": "posts/webr_released/index.html#acknowledgements",
    "href": "posts/webr_released/index.html#acknowledgements",
    "title": "WebR 0.1.0 has been released",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nA massive thank you to all early webR users for their willingness to experiment and their feedback in the form of GitHub issues and pull requests,\n@Anurodhyadav, @barryrowlingson, @christianp, @ekianjo, @georgestagg, @HTUser-1, @jason-variadiclabs, @jjesusfilho, @kdpsingh, @lionel-, @psychemedia, @Sjesc, @SugarRayLua @unclecode, and @wch."
  },
  {
    "objectID": "posts/hyperbolic_fractals/index.html",
    "href": "posts/hyperbolic_fractals/index.html",
    "title": "Hyperbolic fractals",
    "section": "",
    "text": "To skip the maths and play with an interactive fractal browser, click here!\n\nThe Mandelbrot Set\n\nThe Mandelbrot set is probably one of the most famous fractals, known for its self-similar deep zooms and often demonstrated as an example of mathematical beauty.\n\n\n\n\n\n\n\n\n\n\nThe Mandelbrot set smoothly coloured by iteration.\n\n\n\n\n\n\n\nA partial zoomed view of the Mandelbrot set at coordinates (-0.7436,0.1314).\nBoth images generated by Wolfgang Beyer.\n\n\n\n\n\nMathematically, the Mandelbrot set is the set of values \\(c\\in\\mathbb{C}\\) for which the absolute value of the terms in the sequence, \\[z_0=0,\\quad z_{n+1} = z_n^2 + c,\\tag{1} \\] doesn’t fly off to infinity. Equation \\((1)\\) is known as the orbit function for the Mandelbrot set. For example, when \\(c=1\\), the sequence reads \\(z_n = 0, 1, 2, 5, 26, \\dots\\) This sequence in this particular case tends towards infinity and so \\(c=1\\) is not in the Mandelbrot set.\nOne can display all the points in the set on a complex plane to see a basic plot of the famous Mandelbrot shape, but normally a plot is instead produced of the number of iterations before \\(|z_n|\\) is greater than some threshold value. In the above images the iteration count is further smoothed using some extra mathematical tricks.\n\n\nInterpreting the Process Geometrically\nWhen plotting the Mandelbrot set we are associating complex values to points in the 2D plane. The Cartesian coordinates associated with a point \\(z\\) are \\((z_x, z_y)\\), with \\[ z = z_x + iz_y, \\] but an equivalent way of associating \\(z\\) to a point in the plane is by using 2D polar coordinates \\((z_r,z_\\theta)\\), with \\[ z = z_re^{iz_\\theta}.\\] Here \\(z_r\\) is the distance from the origin to the point and \\(z_\\theta\\) is the angle of the point in relation to the \\(x\\) axis. The two systems are related by, \\[ z_x = z_r\\cos(z_\\theta),\\quad z_y=z_r\\sin(z_\\theta). \\tag{2} \\] We can use the Cartesian and polar coordinate systems shown in Equation \\((2)\\) to reinterpret the operations used in Equation \\((1)\\) geometrically.\nFirst, consider the addition operation. This is easily understood by writing the operation in Cartesian form, \\[z + c \\rightarrow (z_x + c_x, z_y+c_y).\\]\nGeometrically, the operation has the effect of translating the point in the \\(x\\) direction by a distance of \\(c_x\\) and in the \\(y\\) direction by a distance of \\(c_y\\). Note that another geometric way of getting to the same point is by first rotating the point associated with \\(z\\) about the origin by \\(-c_\\theta\\), translating it in the \\(x\\) direction by \\(c_r\\), and then finally rotating back about the origin by \\(c_\\theta\\).\nNow consider the operation \\(z^2 = z \\cdot z\\). Rewriting the complex number \\(z\\) in 2D polar form and then simplifying, \\[ z^2 = z_re^{iz_\\theta} \\cdot z_re^{iz_\\theta} = z_r^2e^{i2z_\\theta}. \\] This is still in polar form and shows that the operation \\(z^2\\) takes the point associated with \\(z\\), rotates it about the origin by \\(z_\\theta\\), and then dilates by \\(z_r\\) so that the distance of the point from the origin is squared. Again, there is an alternative geometric method to get to the same point: First take the origin point, translate it in the \\(x\\) direction by \\(z_r^2\\) and then rotate around the origin by \\(2z_\\theta\\).\nUsing the alternative interpretations above, we can think of Equation \\((1)\\) as a set of translations along \\(x\\) and rotations around the origin. Given a value for \\(z\\) and \\(c\\) we can calculate the result of applying Equation \\((1)\\) by finding the complex value associated with the point obtained by applying the following geometric process:\n\nTake the origin point and translate it by \\(z_r^2\\) in the \\(x\\) direction.\nRotate around the origin by \\(2z_\\theta-c_\\theta\\).\nTranslate by \\(c_r\\) in the \\(x\\) direction.\nRotate around the origin by \\(c_\\theta\\).\n\n\nLater, we will use a similar geometric process to define a hyperbolic version of Equation \\((1)\\), set in curved space rather than the standard flat Euclidean space. Since the overall structure of the Mandelbrot set results from the algebra of the complex numbers that we are mimicking with a geometric process, things should not look super different, but with in curved space moving around and zooming into details should at least look fairly interesting.\n\n\n\nHyperbolic Space\nHyperbolic n-space, denoted \\(\\mathbf{H}^n\\), is a homogeneous space that has a constant negative curvature. Curvature here specifically means Gaussian curvature intrinsic to the surface and is a measure of how much geometric objects and operations on the surface deviates from the behaviour in flat space (zero curvature).\n\n\n\nExamples of different types of Gaussian curvature. Image created by Science4All\n\n\n\nTo visualise curved space we need to be able to somehow convert it for display in 2D or 3D Euclidean space, so that it can be sensibly displayed on your screen. However, Hilbert’s theorem says that we can’t embed even a small part of hyperbolic space into 3D Euclidean space due to its constant negative curvature. Luckily, there are several so-called models of hyperbolic space that we can use instead. These models are simply different ways of expressing the structure of hyperbolic space mathematically. We will be using two models: our main calculations will be made in the Hyperboloid Model and we will visualise the result later using the Poincaré Disc Model.\n\n\nThe Hyperboloid Model\n\n\nThe Hyperboloid Model is a model of n-dimensional hyperbolic geometry in which points are associated with points on a hyperboloid surface living in an (n+1)-dimensional non-Euclidean space. A hyperbolic distance function is defined on the surface so that hyperbolic geometry is preserved.\n\n\nOften Minkowski space is used here due to its useful applications in the theory of special relativity. However, I will instead use Lorentz space. It is essentially the same — the coordinates are just re-ordered and some signs are flipped. It doesn’t change the behaviour of the space but does avoid references to physical “time-like” and “space-like” dimensions.\n\n\nWe begin defining Lorentz space by writing down an inner product. For vectors \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\) in \\(\\mathbb{R}^d\\) the Lorentzian inner product is, \\[\\mathbf{u} \\cdot \\mathbf{v} = u_1v_1 + u_2v_2 + \\dots - u_dv_d.\\] This looks very similar to the standard Euclidean inner product expect for the subtraction of the final components. This definition is valid for any vectors \\(\\mathbb{R}^d\\) but we’ll only really consider the case when \\(d=3\\) and denote that space as \\(\\mathbb{L}^{2,1}\\), Lorentz (2,1)-space. Following on from the inner product, we can define both the Lorenz norm and Lorentz distance between two vectors,\\[ ||\\mathbf{u}|| = \\sqrt{\\mathbf{u} \\cdot \\mathbf{u}}, \\] \\[ d_L(\\mathbf{u},\\mathbf{v}) = || \\mathbf{u} - \\mathbf{v} ||. \\]\n\n\nNow, to recreate the geometry of hyperbolic space we need a surface, \\(\\mathcal{H}\\), with constant negative curvature. A sphere with radius \\(r\\) can be shown to have a curvature of \\(\\kappa = \\frac{1}{r^2}\\), so if we could somehow construct a sphere with a radius of \\(r = \\sqrt{-1}\\), we would immediately satisfy our requirements. In analogy to the definition of an n-sphere in Euclidean space we form our surface, \\[\\mathcal{H} =\\{\\mathbf{u} \\in \\mathbb{L}^{2,1} : ||\\mathbf{u}|| = i\\}.\\]\n\n\nIn Euclidean space this is impossible, but as it turns out such a sphere can exist in \\(\\mathbb{L}^{2,1}\\) consisting of all the points \\(\\mathbf{u}\\) satisfying the equation \\(u_1^2+u_2^2-u_3^2 = -1.\\) Back in Euclidean space, this is a two-sheeted hyperboloid and we choose to define our hyperboloid model on the positive sheet only, with \\(u_3&gt;0.\\)\n\n\n\n\n\n\n\n\n\n\nA two-sheeted hyperbolid visualised in 3D Euclidean space. Created by Lars H. Rohwedder.\n\n\n\n\n\n\n\nThe hyperboloid model showing red geodesics, which can be thought of as generalised “straight lines” on the surface. Created by Brice Loustau\n\n\n\n\n\nThe last piece needed to ensure hyperbolic geometry is enforced on the surface of \\(\\mathcal{H}\\) is a hyperbolic distance function, which we define as \\[d_\\mathcal{H}(\\mathbf{u},\\mathbf{v}) = \\mathop{\\text{arccosh}\n}(-\\mathbf{u} \\cdot \\mathbf{v}),\\] so that for any vectors \\(\\mathbf{u},\\mathbf{v} \\in \\mathcal{H}\\), \\[\\mathbf{u}\\cdot \\mathbf{v} = ||\\mathbf{u}||.||\\mathbf{v}||.\\cosh\\left(d_\\mathcal{H}(\\mathbf{u},\\mathbf{v})\\right),\\] in analogy to the geometric formulation of the Euclidean dot product. It’s fairly easy to show that \\(d_\\mathcal{H}\\) satisfies all the criteria to be a metric on the hyperboloid, but I won’t go into all the details here.\n\n\nHyperbolic Mandelbrot Set\n\nLorentz Transformations\nIn the first section we defined the Mandelbrot set in terms of translations and rotations. These operations are really maps from the plane \\(\\mathbb{R}^2\\) back to itself, such that the Euclidean distance between points does not change. To create a hyperbolic analogue we need similar transformations for hyperbolic space. The Lorentz group forms a set of transformations for \\(\\mathbb{L}^{n}\\) that preserves the hyperbolic distance function in exactly the way we need. There are three types of Lorentz transforms (not including the identity) that make up the group. Parabolic, hyperbolic, and elliptic.\nThe elliptic transformations behave essentially the same as Euclidean rotations, defined in terms of an angle. The transformation preserves both the distance between points and the distance between all points and the origin. In the case of the 2D hyperboloid model a rotation of \\(\\theta\\) looks like this, \\[\nR(\\theta) \\mathbf{u} = \\begin{bmatrix}\n\\cos(\\theta) & -\\sin(\\theta) & 0 \\\\\n\\sin(\\theta) &  \\cos(\\theta) & 0 \\\\\n0 & 0            &  1\n\\end{bmatrix} \\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ u_3\n\\end{bmatrix}\n\\]\nThe hyperbolic transformations are similar to Euclidean translations along an axis. They preserve the distance between points, but not the distance between points and the origin. This type of transformation is called a boost and is defined in terms of a hyperbolic angle, also known as the rapidity. In the case of the 2D hyperboloid model a boost with rapidity \\(\\eta\\) looks like this: \\[\nT(\\eta) \\mathbf{u} = \\begin{bmatrix}\n\\cosh(\\eta) & 0 & \\sinh(\\eta) \\\\\n0 & 1 & 0 \\\\\n\\sinh(\\eta) & 0 & \\cosh(\\eta) \\\\\n\\end{bmatrix} \\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ u_3\n\\end{bmatrix}\n\\]\nThe parabolic transformations don’t really have any analogue in Euclidean space, and so we won’t be using them. They do have use in the theory of special relativity and there they are often called null rotations. In case you’re interested, they look like this:\n\\[\nN(\\alpha) \\mathbf{u} = \\begin{bmatrix}\n1-\\frac{\\alpha^2}{2} &  -\\alpha & \\frac{\\alpha^2}{2} &\\\\\n\\alpha & 1 & -\\alpha\\\\\n-\\frac{a^2}{2} & -\\alpha & 1+\\frac{\\alpha^2}{2}\n\\end{bmatrix}\\begin{bmatrix}\nu_1 \\\\ u_2 \\\\ u_3\n\\end{bmatrix}\n\\]\n\n\nHyperbolic Analogue of the Orbit Function\nWe now use the above transformations to recreate the geometric process of Equation \\((1)\\), the orbit function for the Mandelbrot set, with hyperbolic transformations. We first replace Euclidean rotations with Lorentzian rotations and Euclidean translations with boosts. We define analogies to the polar coordinates of \\(\\mathbf{u}\\) in the following way, \\[u_\\eta = d_\\mathcal{H}(\\mathbf{u}, \\mathbf{0}),\\quad u_\\theta = \\mathop{\\text{arctan}}\\left(\\frac{u_2}{u_1}\\right). \\]\nThe result is the following construction for Equation \\((1)\\): Given a \\(\\mathbf{u}, \\mathbf{c} \\in \\mathcal{H}\\), calculate the point on \\(\\mathcal{H}\\) obtained by applying the following geometric process:\n\nTake the origin point, \\(\\mathbf{0} = (0,0,1)\\), and boost it by \\(u_\\eta^2\\).\nRotate around the origin by \\(2u_\\theta-c_\\theta\\).\nBoost by \\(c_\\eta\\).\nRotate around the origin by \\(c_\\theta\\).\n\nThe rest of the process of defining the Mandelbrot set remains the same. Note that the process can be trivially extended to other similar fractals based on orbit functions on the complex plane. For example, the method above can also be used to generate Julia set fractals.\n\n\n\nVisualisation\nThe Poincaré Disc model\nVisualising the hyperboloid model is difficult due to the fact that while the surface is two-dimensional, the hyperboloid itself lives in a three-dimensional Lorenz space. One option could be to simply visualise the hyperboloid surface in 3D, as if it were living in \\(\\mathbb{R^3}\\), and projecting down to your 2D screen in the standard way. However, this would make manipulating the view and getting an intuition for how hyperbolic space really behaves rather difficult since we lose any way to express the hyperbolic distance. Instead, we will project the hyperboloid model down to 2D using the Poincaré Disc model.\nIn this model the entire hyperboloid surface is stereoscopically projected to, and drawn inside, a circular disc. An interesting consequence of this is that you can see the entirety of the infinite surface all at once. It all “fits” because as you move towards the outer boundary the hyperbolic distance between points grows exponentially and features shrink away into nothingness. Using a Poincaré disc neatly demonstrates the different geometries possible in hyperbolic space. For example, you can easily show a tiling of the hyperbolic plane with heptagons while such a tiling is impossible in the Euclidean plane.\n\n\n\n\n\n\n\n\n\nStereoscopic projection from the hyperboloid model to the Poincaré disc, showing how a geodesic maps from one to the other. Created by Selfstudier.\n\n\n\n\n\n\n\nHeptagons uniformly tiling the hyperbolic plane, shown in the form of a Poincaré disc. Created by Anton Sherwood.\n\n\n\n\n\nThe process to stereoscopically project the hyperboloid model to the Poincaré disc is not too difficult. Starting with a point \\(\\mathbf{u}\\) on the hyperboloid, a line is drawn between \\(\\mathbf{u}\\) and \\(\\mathbf{N} = (0,0,-1)\\), intersecting the \\(z=0\\) plane at the required point \\(\\mathbf{p} = (p_1, p_2)\\) on the Poincaré disc. This procedure leads to the following relationship between the points \\(\\mathbf{u} = (u_1, u_2, u_3)\\) on the hyperboloid and \\(\\mathbf{p} = (p_1, p_2)\\) on the disc,\\[\\mathbf{p} = \\left( \\frac{u_1}{u_3+1},  \\frac{u_2}{u_3+1} \\right),\\quad \\mathbf{u} = \\frac{\\left(2p_1, 2p_2, 1+p_1^2+p_2^2\\right)}{1-p_2^2-p_2^2}.\\]\n\n\nHyperbolic Fractal Explorer\nI have created an interactive hyperbolic fractal explorer, shown below. Note that this demo runs using webGL and so the precision of the rotation calculations are fairly limited. The precision loss becomes readily apparent at higher levels of zoom. Nevertheless it’s a fun little demonstration of the ideas above.\nIn addition to the controls in the top right, click and drag to boost around. W will zoom in, S will zoom out and the A and D keys will also boost left and right.\n\n\n\n\n\n\nReferences\nIn addition to the links throughout, here is some more useful reading material.\n\nThe Hyperbolic plane: “A Strange New Universe”\nHyperbolic Geometry and Poincaré Embeddings\nStack Overflow: Is hyperbolic rotation really a rotation?\nWikipedia: Hyperbolic Space\nWikipedia: Poincare Disc\niq: The Main Bulb of the Mandelbrot Set\niq: Smooth Iteration Count for Generalized Mandelbrot Sets\nHyperogue: Models and projections of hyperbolic geometry"
  },
  {
    "objectID": "posts/r_grammar_experiment/index.html",
    "href": "posts/r_grammar_experiment/index.html",
    "title": "An R grammar experiment",
    "section": "",
    "text": "This post was originally published as a Twitter thread.\nRecently I was travelling on a plane without WiFi and so I decided to play with the R source code, which I already had on my laptop. I started experimenting with the file src/main/gram.y, which defines R’s language syntax using rules listed in a variant of Backus-Naur Form.\nI added some new rules to the grammar that adds a different way to invoke R functions. The new syntax looks like XML, and it feels really weird to use functions in this way.\n\n\n\nInvoking functions in the style of XML tags.\n\n\nI set it up so that multiple arguments are space separated child nodes, and named arguments can be added as XML attributes. So, functions with multiple arguments can still be invoked using this strange method. I also made it so R expressions wrapped in curly braces are evaluated.\n\n\n\nNested function invocation and named arguments.\n\n\nWhy was I creating this monster? Well, I was thinking of JSX - a fun extension to JavaScript that allows you to manipulate XML components directly in the JSX source. With this hack, you can almost do the same thing with Shiny and write the UI in HTML. Kinda neat, right?\n\n\n\nA Shiny app, written in a JSX-style using this grammar hack.\n\n\nSo, is this useful in any way? No, probably not. The hack is direct to the R source and I doubt R packages could make this kind of change. So even if you really wanted to do it, you’d have to run a patched version of R. A fun little experiment in writing BNF rules, though."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html",
    "href": "posts/webr_0.2.0/index.html",
    "title": "WebR 0.2.0 has been released",
    "section": "",
    "text": "This post was originally published as an article on the Tidyverse Blog.\nWe’re absolutely thrilled to announce the release of webR 0.2.0! This release gathers together many updates and improvements to webR over the last few months, including improvements to the HTML canvas graphics device, support for Cairo-based bitmap graphics, accessibility and internationalisation improvements, additional Wasm R package support (including Shiny), a new webR REPL app, and various updates to the webR developer API.\nThis blog post will take a deep dive through the major breaking changes and new features available in webR 0.2.0."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#webassembly-and-webr",
    "href": "posts/webr_0.2.0/index.html#webassembly-and-webr",
    "title": "WebR 0.2.0 has been released",
    "section": "WebAssembly and webR",
    "text": "WebAssembly and webR\nMy previous webR release blog post goes into detail about what WebAssembly is, why people are excited about it, and how it relates to the R community and ecosystem in general through webR. I would recommend it as a good place to start, if the project is new to you1.\n1 In addition, Danielle Navarro’s webR blog post is very good and Bob Rudis’s webR experiments are well worth exploring, along with his recent NY R conference talk.2 Also other JavaScript/Wasm environments, such as Node.js. For example, ROpenSci’s r-universe package platform provides download links for datasets contained in R packages, in a variety of formats, powered by running webR server-side in Node.js.A short explanation is that WebAssembly (also known as Wasm) allows software that’s normally compiled for a specific computer system to instead run anywhere, including in web browsers. Wasm is the technology that powers Pyodide (used by Shinylive for Python) and webR brings this technology to the R world. Using webR it is possible to run R code directly in a web browser2, without the need for the traditional supporting R server to execute the code.\nRunning R code directly in a browser opens the door for many new and exciting uses for R on the web. Applications that I’m personally excited in seeing developed are,\n\nLive and interactive R code and graphics in documents & presentations,\nTactile educational content for R, with examples that can be remixed on-the-fly by learners,\nReproducible statistics through containerisation and notebook-style literate programming.\n\nEven in these early days, some of this is already being provided by development of downstream projects such as James Balamuta’s quarto-webr extension, allowing Quarto users to easily embed interactive R code blocks in their documents.\n\nInteractive code blocks\nOne of my favourite demonstrations of what webR can do is interactive code blocks for R code. After a short loading period while the webR binary is downloaded, a Run code button will be enabled below. Using examples like this, R code can be immediately edited and executed – feel free to experiment! Click the “Run code” button to see the resulting box plot, change the colour from mediumseagreen to red and run the code again.\n\nLoading webR…\n\n\n\n\n\n\n\n\nIt’s easy to see the potential teaching benefit examples like this could bring to educational content or R package documentation."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#the-webr-repl-app",
    "href": "posts/webr_0.2.0/index.html#the-webr-repl-app",
    "title": "WebR 0.2.0 has been released",
    "section": "The webR REPL app",
    "text": "The webR REPL app\nWebR can be loaded into a web page to be used as a part of a wider web application, and ships with a demo application that does just that. The webR REPL app3 provides a simple R environment directly in your web browser. The app can be accessed at https://webr.r-wasm.org/v0.2.0/ and includes sections for R console input/output, code editing, file management, and graphics device output.\n3 REPL stands for “Read, Eval, Print, Loop”, and is another name for the R console that you’re probably familiar with. The application is named the “webR REPL app” because the original version simply provided the user with a fullscreen R console in their web browser.With the webR REPL app, a casual user could get up and running with R in seconds, without having to install any software on their machine. It is entirely feasible that they could perform the basics of data science entirely within their web browser!\nOther than interactive code blocks, like in the example earlier, the webR REPL app is perhaps the first thing that users new to webR will interact with. For this reason, we have spent some time working to improve the technical implementation and user experience of using the app. The app has been completely rewritten in the React web framework, replacing the older jQuery library. This allows for better component code organisation and more rapid development of features and updates.\n\n\nCode editor\nThe app now comes with a tabbed code editor, allowing for easier editing and execution of R code. The editor integrates with the webR virtual filesystem (VFS), meaning that multiple R scripts can be opened, edited, and saved and they will be available to the running Wasm R process.\nThe editor pane is built upon the excellent CodeMirror text editor, which provides most of the component’s functionality. CodeMirror provides built-in support for syntax highlighting of R code, which is enabled by default when R source files are displayed.\nThe editor is integrated with the currently running R process and automatic code suggestions are shown as you type, provided by R’s built in completion generator. The suggestions are context sensitive and are aware of package and function names, valid arguments, and even objects that exist in the global environment.\n\nThe running Wasm R process is also configured at initialisation to use the editor component as its display pager mechanism. With this configuration in place running commands such as ?rnorm in the app automatically opens a new read-only tab in the editor displaying R’s built-in documentation.\n\n\n\nPlotting pane\nThe plotting pane has been updated to take advantage of improvements in webR’s HTML canvas graphics device, set as the default device as part of initialisation. In particular, multiple plots are now supported and older plots can be directly accessed using the previous and next buttons in the plotting toolbar. You can try this out with R’s built in graphics demo, by running demo(graphics) and/or demo(persp).\n\n\n\nFiles pane\nThe files pane has been completely redesigned, removing its dependency on jQuery and instead making use of the react-accessible-treeview package. As well as a technical improvement, this change means that interacting with the webR filesystem should be more usable to those with web accessibility requirements. We feel it’s important that, where possible, everybody is able to use our software.\n\nAdditional buttons have also been added to this pane, allowing users to easily manipulate the virtual file system visible to the running Wasm R process. New files and directories can be created or deleted, and text-based files can be directly opened and modified in the editor pane, removing the need to download, edit and then re-upload files.\n\n\nConsole pane\nThe R console component shown in the lower left portion of the app is powered by the wonderful xterm.js software, which provides a high performance terminal emulator on the web. R output looks at its best when running in this kind of environment, so that ANSI escape codes can be used to provide a much smoother console experience incorporating cursor placement, box drawing characters, bold text, terminal colours, and more.\n\nAn optional accessibility mode is provided by xterm.js so that terminal output is readable by screen reader software, such as macOS’s VoiceOver. The webR REPL app now enables this mode by default to improve the accessibility of terminal output."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#html-canvas-graphics-device",
    "href": "posts/webr_0.2.0/index.html#html-canvas-graphics-device",
    "title": "WebR 0.2.0 has been released",
    "section": "HTML Canvas graphics device",
    "text": "HTML Canvas graphics device\nThe webR support package provides a custom webr::canvas() graphics device that renders output using the Web Canvas API. When the graphics device is used, drawing commands from R are translated into Canvas API calls. The browser renders the graphics and the resulting image data is drawn to a HTML &lt;canvas&gt; element on the page.\nWith the release of webR 0.2.0, we have improved the performance and added new features to the HTML canvas graphics device.\n\nPerformance improvements with OffscreenCanvas\nUsing the Canvas API to draw graphics in a browser is elegant, but presents a problem. R is running via WebAssembly in a JavaScript Web Worker thread, but the &lt;canvas&gt; element the plot image data is written to is on the main thread, part of the web page DOM. And, unfortunately, JavaScript Web Worker threads have no direct access to the DOM.\nPrevious releases of webR solve this problem in a rather naive way, it simply sends the Canvas API calls to the main thread to be executed there. This leads to a few issues,\n\nCanvas API calls are serialised as text to be sent to the main thread. Sufficiently complex plot text must therefore be quoted and escaped.\nEach API call is sent in a separate message. For a complex plot this can be thousands of messages to dispatch and handle.\nThe messaging is one-way, results of useful methods like measureText() cannot easily be retrieved.\nParsing and executing the API call on the main thread means using JavaScript’s eval() or Function(), leading to poor performance. These functions should also be avoided when possible in any case, for security reasons.\n\nSolid engineering efforts could be made to improve the situation, e.g. through batching API calls and better encoding, but there is a better way: the OffscreenCanvas interface. OffscreenCanvas is designed to solve this exact problem of rendering graphics off-screen, such as in a worker thread. With OffscreenCanvas the Canvas API calls can all be executed on the worker thread, and only a single message containing the completed image data transferred to the main thread when rendering is complete. It is an efficient and technically satisfying solution, except that when webR 0.1.1 was released OffscreenCanvas wasn’t supported by the Safari web browser.\nToday, on the other hand, OffscreenCanvas is supported in all major desktop and mobile browsers. Safari has supported it since version 16.4, and so with webR 0.2.0 we have rewritten the webr::canvas() graphics device to take full advantage of the OffscreenCanvas interface. This has led to a significant performance improvement, particularly when creating plots containing many points. The two videos below show the same plot rendered in webR 0.1.1 and 0.2.0, the difference is not just visible, but an order of magnitude faster.\n\n\n\n\nA performance comparison plotting 300000 points in webR 0.1.1 and 0.2.0.\n\nA potential downside is that users of less up-to-date browsers without OffscreenCanvas support won’t be able to use the webr::canvas() graphics device. Such users should instead make use of our additional updates to webR to support the traditional Cairo-based bitmap devices. The built-in graphics devices section discusses that in more detail.\n\n\nModern text rendering and internationalisation\nWith webR 0.1.1, the canvas graphics device had only minimal support for rendering text. The typeface was fixed, the font metrics were estimated with a heuristic, and Unicode characters outside the Basic Latin block often failed to render. It worked most of the time, but it was far from ideal. This area of software engineering is suprisingly difficult to get right, and even native installations of R can have serious text rendering issues.\nIn comparison, web browser support for text rendering is excellent. Now that we use the OffscreenCanvas interface, we too can take advantage of the years of work behind browser’s support for text on the web. The example below demonstrates several of the modern text rendering features now supported by webr::canvas().\n\nLoading webR…\n\n\n\n\n\n\n\n\nAny system font available to the web browser can now be used4. As well as a nice-to-have, this also provides improved accessibility. For example, there are fonts designed specifically for use by readers with dyslexia and other similar reading barriers5 that could be used for drawing text in plots.\n4 This also includes the world of CSS web fonts, but it is a little tricky. Extra work must be done so that the font is available to the Web Worker. Probably this can be handled better in a future release of webr::canvas().5 Dyslexie, Open Dyslexic. Results of research in this area is mixed, but even if these fonts don’t improve the speed of text comprehension, some users may simply prefer or feel more comfortable with them.Font metrics are now exact, using measureText(), rather than estimating the width and height of Latin glyphs using heuristics. This gives more accurate positioning of rendered text and improves the general quality of resulting plots.\nSupport for Unicode, font glyph fallback, complex ligatures, and right-to-left (RTL) text have all been improved. This vastly improves results when rendering text for international users, particularly for non-Latin RTL scripts such as the Arabic and Hebrew text in the example above.\nAlso, colour emoji can now be added to plots. 😃\n\n\nPaths and winding rules\nAdditional support for the drawing and filling of paths and polygons, including with different winding rules, has been added to the webR canvas graphics device. An area where this new functionality makes a world of difference is plotting spatial features and maps. Previously broken R code for plotting maps with the ggplot2 and sf packages now works well with webR 0.2.0.\n\n\n\nOutput messages from the canvas graphics device\nAs a result of the changes to the HTML canvas graphics device, the structure of output messages communicated to the main thread has been redesigned. This is a breaking change and existing webR applications will need to be updated to listen for the new output messaging format.\nA Plotting section has been added to the webR documentation describing how plotting works with the webr::canvas() device, and how to handle the output messages in your own web applications.\nA 'canvas' type output message with an event property of 'canvasNewPage' indicates the start of a new plot,\n{ type: 'canvas', data: { event: 'canvasNewPage' } }\nAn output message with an event property of 'canvasImage' indicates that there is some graphics data ready to be drawn,\n{ type: 'canvas', data: { event: 'canvasImage', image: ImageBitmap } }\nThe image property in the message data contains a JavaScript ImageBitmap object. This can be drawn to a HTML &lt;canvas&gt; element using the drawImage() method."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#built-in-bitmap-graphics-devices",
    "href": "posts/webr_0.2.0/index.html#built-in-bitmap-graphics-devices",
    "title": "WebR 0.2.0 has been released",
    "section": "Built-in bitmap graphics devices",
    "text": "Built-in bitmap graphics devices\nNot all environments where webR could be running support plotting to a HTML &lt;canvas&gt; element. Older browsers may not support the required OffscreenCanvas interface, webR might be running server-side in Node.js, or webR might be running more traditional R code or packages that are unaware of the webr::canvas() graphics device.\nFor supporting these use cases, with webR 0.2.0 the built-in bitmap graphics devices are now able to be used, writing their output to the webR VFS. This includes the png(), bmp(), jpeg(), tiff() devices, and potentially others implemented using the Cairo graphics library.\nIn the example below, webR is loaded into a JavaScript environment and plotting is done using the built-in png() graphics device. The resulting image is written to the virtual filesystem and its contents can then be obtained using webR’s FS interface, designed to be similar to Emscripten’s filesystem API.\nimport { WebR } from 'webr';\n\nconst webR = new WebR();\nawait webR.init();\n\nawait webR.evalRVoid(`\n  png('/tmp/Rplot.png', width = 800, height = 800, res = 144)\n  hist(rnorm(1000))\n  dev.off()\n`);\n\nconst plotImageData = await webR.FS.readFile('/tmp/Rplot.png');\nThe image data is contained in the plotImageData variable as a JavaScript UInt8Array. Once obtained from the VFS, the image can be served to the end user as a Blob file download, displayed on a web page, or if running webR server-side returned over the network.\n\nText rendering and font support\nAs with the webr::canvas() improvements described in the previous section, we feel it is important that the built in R graphics devices provides a high level of support for text rendering in webR. Here, however, the approach is different. The built-in graphics devices renders image data entirely within the WebAssembly environment, so we can no longer rely on the web browser for high quality text!\nThe built-in graphics devices are powered by the Cairo graphics library, which can now optionally be compiled for Wasm as part of the webR build process. In addition, when enabled various other libraries are compiled for Wasm to improve the quality of text rendering in Cairo,\n\npango\nfribidi\nharfbuzz\nfreetype\nfontconfig\n\nPublic releases of webR distributed via GitHub and CDN will be built with these libraries all enabled and included.\n\nFont files on the VFS\nWhen plotting with the built-in bitmap graphics devices, fonts must be accessible to the Cairo library through the webR VFS. A minimal selection of Google’s Noto fonts are bundled with webR when Cairo graphics is enabled.\nThe fontconfig library is also configured to search the VFS directory /home/web_user/fonts for additional fonts. Users who wish to use custom fonts, or alternative writing systems, may do so by uploading font files to this directory. In the case of international scripts or non-Latin Unicode such as emoji, fontconfig will automatically use font fallback to select reasonable fonts containing the required glyphs.\npng(width = 1200, height = 800, res = 180)\nplot(\n  rnorm(1000), rnorm(1000),\n  col = rgb(0, 0, 0, 0.5),\n  xlim = c(-5, 5), ylim = c(-5, 5),\n  main = \"This is the title 🚀\",\n  xlab = \"This is the x label\",\n  ylab = \"This is the y label\"\n)\ntext(-3.5, 4, \"This is English\")\ntext(-3.5, -4, \"هذا مكتوب باللغة العربية\")\ntext(3.5, 4, \"これは日本語です\")\ntext(3.5, -4, \"זה כתוב בעברית\")\ndev.off()\nThis is essentially the same example as in the previous section, demonstrating a selection of advanced font functionality. In this example we are rendering a PNG file using the built-in png() graphics device. We can see that by uploading appropriate fonts to the VFS, the same set of advanced text rendering features that are provided by the browser can also be used with R’s built-in bitmap graphics devices."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#lazy-virtual-filesystem",
    "href": "posts/webr_0.2.0/index.html#lazy-virtual-filesystem",
    "title": "WebR 0.2.0 has been released",
    "section": "Lazy virtual filesystem",
    "text": "Lazy virtual filesystem\nAll of the additional features I’ve written about so far come with a price: increased Wasm binary and data download size. Consider the fonts in the previous section - each font file bundled with webR is going to increase the total size of the default webR filesystem by around 500KB.\nThis is a high price to pay in time and bandwidth when not every user is going to need every feature. A similar principle also applies to other files included with R by default. It’s nice that all the default R documentation, examples, and datasets are available on the VFS, but we don’t necessarily need those files downloaded every time to every client machine.\nWith webR 0.2.0 a “lazy” virtual filesystem mechanism, powered by a feature of Emscripten’s FS API, is introduced. With this, only the files required to launch R and use the default packages are downloaded at initialisation time. Additional files provided on the VFS are still available for use, but they are only downloaded from the remote server when they are requested in some way by the running Wasm R process.\nWith the introduction of the lazy virtual filesystem, along with other efficiency improvements, the initial download size for webR is now much smaller, a great improvement.\n\n\n\nComponent\n0.1.1\n0.2.0\n(% of previous)\n\n\n\n\nR.bin.data\n25.3MB\n5.2MB\n20.6%\n\n\nR.bin.wasm\n12.8MB\n1.7MB\n7.5%\n\n\nTotal for the webR REPL app\n40.2MB\n9.5MB\n23.6%"
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#r-packages",
    "href": "posts/webr_0.2.0/index.html#r-packages",
    "title": "WebR 0.2.0 has been released",
    "section": "R packages",
    "text": "R packages\nSince initial release, webR has supported loading R packages by first installing them to the Emscripten VFS using the helper function webr::install() or by manually placing R packages in the VFS at /usr/lib/R/library. We find that pure R packages usually work well, but R packages with underlying C (or Fortran, or otherwise…) code must be compiled from source for Wasm.\nWe host a public CRAN-like R package repository containing packages built for Wasm in this way, so that there exists a subset of useful and supported R packages that can be used with webR. The public repository is hosted at https://repo.r-wasm.org and this repo URL is used by default when running webr::install() to install a Wasm R package.\nIt remains the case that building custom R packages for Wasm is not well documented, but we do hope to improve the situation over time as our package build infrastructure develops and matures. In the future, we plan to provide a Wasm R package build system as a set of Docker containers, so that users are able to build their own packages for webR using a container environment.\n\nWebAssembly system libraries for R packages\nMany R packages require linking with system libraries to build and run. When building such R packages for WebAssembly, not only does the package code require compiling for Wasm, but also any system libraries that code depends on.\nTo expand support for R packages, webR 0.2.0 ships with additional recipes to build system libraries from source for Wasm. The libraries consist of a selection of utility, database, graphics, text rendering, geometry, and geospatial support packages, with specific libraries chosen for their possibility to be compiled for Wasm as well as the number of R packages relying on them. I expect that the number of system libraries supported will continue to grow over time as we attempt to build more R packages for Wasm.\nAs of webR 0.1.1, 219 packages were available to install through our public Wasm R package repo. With the release of webR 0.2.0 and its additional system libraries, the number of available packages is now 10324 (approximately 51% of CRAN packages). Though, it should be noted that these packages have not been tested in detail. Here, “available” just means that the Emscripten compiler successfully built the R package for Wasm, along with its prerequisite packages.\n\n\nPublic Wasm R packages dashboard\nWhile available R packages can be listed using available.packages() with our CRAN-like Wasm R package repo, it’s not the smoothest experience for users simply wanting to check if a given package is available. A dashboard has been added to the repo index page which lists the available packages compiled for Wasm in an interactive table. The table also lists package dependencies, noting which prerequisite packages, if any, are still missing.\n\nIt might be interesting to note that this dashboard itself is running under webR, through a fully client-side Shiny app."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#running-httpuv-shiny-under-webr",
    "href": "posts/webr_0.2.0/index.html#running-httpuv-shiny-under-webr",
    "title": "WebR 0.2.0 has been released",
    "section": "Running httpuv & Shiny under webR",
    "text": "Running httpuv & Shiny under webR\nUsing features new to webR 0.2.0, a httpuv webR package shim has been created that provides the functionality usually provided by the httpuv R package. The package enables R to handle HTTP and WebSocket traffic, and is a prerequisite for the R Shiny package.\nThe shim works by taking advantage of the JavaScript Service Worker API. Normally Service Workers are used to implement fast offline caching of web content, but they can also be used as a general network proxy. The httpuv shim makes use of a Service Worker to intercept network traffic from a running Shiny web client, and forward that traffic to be handled by an instance of webR.\nFrom the Shiny server’s point of view, it is communicating with the usual httpuv package using its R API. From the point of view of the Shiny web client, it is talking to a Shiny server over the network. Between the two, the JavaScript Service Worker and webR work together to act as a network proxy and handle the traffic entirely within the client6.\n6 Shinylive for Python also uses a JavaScript Service Worker scheme to serve fully client-side apps.\nThe httpuv shim package is still in the experimental stage, but it is currently available for testing and is included in our public webR package repository.\n\nAn example shiny app\n\nAn example Shiny app, making use of the httpuv shim and running fully client-side, is available at https://shiny-standalone-webr-demo.netlify.app.\nOnce the app has loaded in your browser, it’s possible to confirm that the app is running entirely client-side by observing the Shiny server trace output at the bottom of the screen. You should even be able to disconnect completely from the internet and continue to use the app offline.\nThe source code for the demo, which includes some information describing how to set up a webR Shiny server in this way, can be found at georgestagg/shiny-standalone-webr-demo. Note that this repository is targeted towards advanced web developers with prior experience of development with JavaScript Web Workers. It is intended as a demonstration of the technology, rather than a tutorial.\nA coming-soon version of Shinylive for R will provide a much better user experience for getting fully client-side R Shiny apps up and running, without requiring advanced knowledge of JavaScript’s Worker API. I believe Shinylive with webR integration will pave the way for providing a user-friendly method to build and deploy containerised R Shiny apps, running on WebAssembly."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#changes-to-the-webr-developer-api",
    "href": "posts/webr_0.2.0/index.html#changes-to-the-webr-developer-api",
    "title": "WebR 0.2.0 has been released",
    "section": "Changes to the webR developer API",
    "text": "Changes to the webR developer API\nIt’s possible for webR to be used in isolation, but it’s likely that developers will want to interface webR with other JavaScript frameworks and tools. The dynamism and interconnectivity of the web is one of its great strengths, and we’d like the same to be true of webR. This section describes changes to webR’s developer API, used to interact with the running R session from the JavaScript environment.\n\nPerformance improvements with MessagePack protocol\nWhen working to integrate webR into a wider application, at some point we will need to move data into the running R process, and later return results back to JavaScript. It’s possible to move data into R by evaluating R code directly, but the webR library also provides other ways to transfer raw data to R.\nConsider the example below. Data is transferred from JavaScript into the running R process by binding jsData to an R variable in the global environment using webR.objs.globalEnv.bind(). Next, some computation on the data is done, represented as evaluating the do_analysis() R function. Finally the result is returned back to JavaScript, first as a reference to an R object and then transferring the result data back to the JavaScript environment using toJs().\nconst jsData = [... some large JavaScript dataset ...];\nawait webR.objs.globalEnv.bind('data', jsData);\n\nconst ret = await webR.evalR(\"do_analysis(data)\");\nconst result = await ret.toJs();\nIt’s easy to see how this workflow could be useful as part of a wider application, enabling a complex data manipulation or a statistical modelling in R that would otherwise be awkward to perform directly in JavaScript.\nBehind the scenes, we’ve done work to ensure that data is transferred efficiently to and from the R environment, and in webR 0.2.0 the MessagePack protocol is now used as the main way that data is serialised and transferred, replacing JSON encoding.\nThis change provides a significant performance improvement. Initial testing shows an order of magnitude speed boost when transferring large sets of data from the JavaScript environment into R. Thanks to @jeroen for prompting me to look into it!\n\n\nThe typing of R object references\nWhen working with webR in TypeScript it is important to keep track of R object types. All references to R objects are instances of the RObject class, and various subclasses implement specific features for each fundamental R data type.\nIn this example, an RDouble object is returned at runtime, but webR.evalR() is typed to return a generic RObject. Notice that the .toNumber() method exists on RDouble, but not on the RObject superclass. So while this example runs with no problem once compiled to JavaScript, it gives an error under TypeScript!\nconst obj = await webR.evalR('1.23456');\nconst data = await obj.toJs();\n\nconst num = await obj.toNumber(); // An error under TypeScript!\nOne solution is to use the as keyword to assert a specific type of RObject subclass. Alternatively, webR also provides variants of the evalR() function that return and convert results to a specific type of JavaScript object.\nIn many cases these methods will work well, but they require you to know for sure what type of R object has been returned. Additional support has been added in webR 0.2.0 to better handle typing when it is not entirely clear what type of RObject you have.\n\nType predicate functions\nTypeScript supports a kind of return type known as a type predicate. These return types can be used to create user-defined type guards, functions that take an object argument and return a boolean indicating if the object is of a compatible type. With this, TypeScript is able to automatically narrow types based on the return value from the type predicate function.\nWebR 0.2.0 ships with a selection of type predicate functions for each fundamental R data type supported by webR. In the following example, the TypeScript error described above is dealt with by using the function isRDouble(). Inside the branch, TypeScript narrows the object type to an RDouble, resolving the issue.\nimport { isRDouble } from 'webr';\n\nconst obj = await webR.evalR('1.23456');\n\ntry {\n  if (isRDouble(obj)) {\n    // In this branch, TypeScript narrows the type of `obj` to an `RDouble`\n    const num = await obj.toNumber();\n  \n    // Do something with `num` ...\n  }\n} finally {\n  webR.destroy(obj);\n}\n\n\n\nHandling errors with WebRError\nWhen executing R code with webR’s evalR() family of functions, by default any error condition from R is converted into a JavaScript Error and thrown. This feature can be very useful, because it allows developers to catch issues while executing R code in the native JavaScript environment.\nHowever, consider the following example,\ntry {\n  const result = await webR.evalR('some_R_code()');\n  doSomethingWith(result);\n} catch (e) {\n  // Handle some error that occured\n}\nIf an error is thrown, how can we tell if the error came from R or from some issue inside the JavaScript function? Nested try/catch could be used, but this becomes unwieldy quickly. Parsing the error message text is another option, though not so elegant.\nWith webR 0.2.0 any errors that occur in R code executed using evalR(), or any internal webR issues, are thrown as instances of WebRError. With this change, the instanceof keyword can be used to differentiate between errors occurring in R, and errors in JavaScript code.\nimport { WebRError } from 'webR';\n\ntry {\n  const result = await webR.evalR('some_R_code()');\n  doSomethingWith(result);\n} catch (e) {\n  if (e instanceof WebRError) {\n    console.error(\"An error occured executing R code\");\n  } else {\n    console.error(\"An error occured in JavaScript\");\n  }\n  throw e;\n}\n\n\nSafely handling webR termination\nConsider the following async loop, a useful pattern to continuously handle webR output messages,\nasync function run() {\n  for (;;) {\n    const output = await webR.read();\n    switch (output.type) {\n      case 'stdout':\n      case 'stderr':\n        console.log(output.data);\n        break;\n      default:\n        console.warn(`Unhandled output type: ${output.type}.`);\n    }\n  }\n}\nHere await webR.read() waits asynchronously for output messages from webR’s communication channel. For example, a running R process might print results between long computational delays. Such occasional printed output might be received as messages with a type property of 'stdout'.\nAfter a message is received, it is handled in a switch statement and then the loop continues around to wait for another output message. This works well while webR is running, but what happens when terminated with webR.close()? The R worker thread is stopped and destroyed, but the loop continues to wait for a message that will never come.\nWith webR 0.2.0 a new type of message is issued when webR is terminated using webR.close(). After the webR worker thread has been destroyed, a message is emitted on the usual output channel with a type property of 'closed', with no associated data property. The implication is that once this message has been emitted, that particular instance of webR has terminated and the the async loop is no longer needed.\nWith this change, exiting the loop once webR has terminated could be as simple as adding an extra case statement,\nasync function run() {\n  for (;;) {\n    const output = await webR.read();\n    switch (output.type) {\n      case 'stdout':\n      case 'stderr':\n        console.log(output.data);\n        break;\n      case 'closed':\n        return;\n      default:\n        console.warn(`Unhandled output type: ${output.type}.`);\n    }\n  }\n}"
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#installation-and-next-steps",
    "href": "posts/webr_0.2.0/index.html#installation-and-next-steps",
    "title": "WebR 0.2.0 has been released",
    "section": "Installation and next steps",
    "text": "Installation and next steps\nDevelopers can integrate webR in their own JavaScript or TypeScript projects by installing the webR npm package, or by directly importing webR from CDN. Issues and PRs are accepted and welcome on the main r-wasm/webr GitHub repository.\n\nnpm\nWith this release, the webR npm package name has been updated, simplified from the original @r-wasm/webr package name to simply webr.\nnpm i webr\nThe original namespaced package @r-wasm/webr will be deprecated, and from v0.2.0 onwards npm will display a message pointing to the new package name.\n\n\nCDN URL\nAlternatively, webR can be imported directly as a module from CDN.\nimport { WebR } from \"https://webr.r-wasm.org/v0.2.0/webr.mjs\"\n\n\nBinary release packages\nFinally, binary webR packages can be downloaded from GitHub on the releases page of the r-wasm/webr repo.\n\n\nDocumentation\nThe next step of integrating webR into your own software should be to visit the documentation pages, provided at https://docs.r-wasm.org/webr/v0.2.0/. My previous webR release blog post also briefly explains how to get started, though the docs go into much more detail."
  },
  {
    "objectID": "posts/webr_0.2.0/index.html#acknowledgements",
    "href": "posts/webr_0.2.0/index.html#acknowledgements",
    "title": "WebR 0.2.0 has been released",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nA big thank you to all of webR’s early adopters, experimenting with the system and providing feedback in the form of GitHub Issues and PRs.\n@Anurodhyadav, @arkraieski, @averissimo, @awconway, @bahadzie, @ceciliacsilva, @DanielEWeeks, @eteitelbaum, @fortunewalla, @gedw99, @gwd-at, @hatemhosny, @hrbrmstr, @ivelasq, @JeremyPasco, @jeroen, @jooyoungseo, @jpjais, @kforner, @lauritowal, @lionel-, @matthiasbirkich, @neocarto, @noamross, @Polkas, @qiushiyan, @ries9112, @SugarRayLua, @timelyportfolio, @WebReflection, and @WillemSleegers."
  },
  {
    "objectID": "posts/diy_synth/index.html",
    "href": "posts/diy_synth/index.html",
    "title": "DIY FM synthesiser",
    "section": "",
    "text": "This post was originally published as a Twitter thread.\nFor anyone looking for an electronics/soldering project I can’t recommend this DIY OPL2 audio board enough. It comes with everything you need, is very fun to build, does not take too long and when you’re done you have an FM synthesiser to play with!\n\n\n\nThe OPL2 Audio Board by Cheerful Electronics.\n\n\nThe OPL2 (aka YM3812) was an FM synthesis chip from Yamaha. It has two oscillators, nine channels and a variety of parameters and effects to play with. It is well known for powering early IBM PC sound cards (e.g Adlib, 1987) and Yamaha’s PSR synths (e.g PSR-11/12 1986).\n\n\n\nAbove: Adlib sound board. Below: Yamaha PSR-12.\n\n\nOnce you’ve built the OPL2 board, you can hook it up to something like a Raspberry Pi or Arduino to drive it, and synthesise some FM style bleeps and bloops! The board has an audio out jack right there, and has an amplifier so you can plug headphones or speakers in.\nHere is an image of the board hooked up to an Arduino Nano clone, a cheap 1.8in TFT screen, and a keypad matrix. Using Arduino libraries for the board and the TFT screen, I wrote some Arduino code to create a DIY synthesiser.\n\n\n\nOPL2 Audio Board, keypad matrix, Arduino Nano clone, and TFT screen showing an instrument editor screen.\n\n\nHere is a video showing my Instrument Editor. The graphical interface is drawn to the screen using the Arduino TFT library and from there you can use the attached keypad matrix to edit the FM parameters and play notes (using the OPL2 library).\n\n\n\n\n\n\n\n\n\nAlthough much less developed, here is a Pattern Editor page I never quite finished. The idea here was to create something very similar to old school tracker software, inputting notes for each channel into the pattern editor and playing patterns back to create music.\n\n\n\nThe pattern editor screen.\n\n\nEagle eyed viewers might notice the SD card plugged into the screen. The Arduino uses SPI to talk to everything: the TFT screen, the OPL2 board, and that SD card. The OPL2 instrument parameters and tracker patterns are saved and read back directly to the SD card in this way.\n\n\n\nA closer look at the TFT board, including it’s SD card reader slot.\n\n\nSince the OPL2 was used to create sound expansion cards for the IBM PC in the 80s, if you have any old tracker files lying around the OPL2 library can actually play them direct from the SD card. Here is a random one that I found on the web.\n\nAnd here’s a fun version of Popcorn! Apologies for the secondhand recording of the audio rather than direct line-in. The OPL2 sounds amazing in person. Well, if you’re into that kind of thing…"
  },
  {
    "objectID": "posts/calculator_forth/index.html",
    "href": "posts/calculator_forth/index.html",
    "title": "Forth on a calculator",
    "section": "",
    "text": "This post was originally published as a Twitter thread.\nUpdate: Since originally posting this, I’ve seen a video on YouTube discussing colour LCD displays which briefly mentions this family of calculators. It, along with many other videos on the same channel, is wonderful to watch.\n\nI’m currently suffering with Covid-19. In “celebration”, here is a twitter thread describing my Covid lockdown project: hacking a Casio CFX-9850G calculator, from 1996 with 32KB of RAM and a 128x64 LCD screen, to run custom machine code.\n\n\n\nMy CFX-9850G graphing calculator.\n\n\nWhy? It all began when a friend of mine told me he prefers using the dc command over bc, as he is used to using reverse polish notation (RPN) on his calculator. My CFX-9850G, on the other hand, uses the more common infix notation. A comparison is shown here.\n\n\n\nThe bc and dc CLI calculators.\n\n\nThe CFX-9850G supports programming with Casio BASIC, which suppose I could have used, but it’s slow. To do this properly meant learning about how the calculator CPU works and somehow running my own machine code on the thing.\nI tried to learn as much as I could about the hardware. I found a service manual and partial documentation of the calculator’s CPU by Martin Poupe at http://martin.poupe.org/casio/. This was super helpful and confirmed that it was indeed possible to run custom code.\nI took apart the calculator and removed the ROM chip (a NEC branded 23C400). The plan was to dump the ROM, and then later solder in a new chip programmed with modified data. It took a few attempts to get a clean ROM dump, mostly due to my shoddy soldering. In retrospect, it would have been much easier to just use an adapter board or ZIF socket/clip.\n\n\n\nLeft: The CFX-9850G’s motherboard, ROM removed. Right: The NEC branded 23C400 SOIC chip, wires soldered to each pin.\n\n\nI was able to dump the ROM using a universal EEPROM programmer, the widely available MiniPro TL866.\nNow that I had a ROM dump, I could start seeing how the calculator’s built in OS works. Based on Martin’s previous work, I started writing a disassembler for the calculator’s Hitachi HCD62121 so that I could convert the ROM data into readable assembly listings.\nAt the same time, I amazingly found a partial implementation of the CPU in MAME’s source code, again based on work by Martin Poupe. Unfortunately, the MAME emulation didn’t work with my ROM, just showing a blank screen or crashing.\nSo, I made my own emulator. I used the partially working MAME core as a base, along with Martin’s CPU information and the Casio service manual to understand how the CPU, ROM, display and keypad all work together. The right side of the screen shows the CPU and RAM internals of the machine, along with controls to step through individual instructions, providing a simple debugger.\n\n\n\nThe CFX emulator I created as a sandbox for experimentation.\n\n\nI then used the emulator to watch things as my ROM dump booted, tweaking the emulation until it finally worked. IIRC the problem was due to timing/sleep issues causing the calculator to immediately just turn off. Normally it does that after about 5 minutes to save power!\n\n\n\nCasio’s calculator OS, as dumped from my calculator’s ROM chip, running on the CFX emulator.\n\n\nWith a working emulator I could patch the ROM and test custom machine code. I patched my ROM to replace one of the Casio BASIC commands with a new one. That new command was programmed to jump to a specific location in RAM and then run whatever is there.\nAt this point I bought some new blank AT27C040 chips from AliExpress. They are pin-compatible with the ROM chip I pulled from the calculator, and can be programmed with a EEPROM programmer.\n\n\n\nWriting a custom ROM for the calculator using the TL866 programmer. I do wish that board had fit directly into the ZIF socket, so that I could avoid all the wires. Alas, it was slightly too wide.\n\n\nYou’ll notice I’ve also switched from directly soldering to the EEPROM chip to using an adapter board instead. I burned in my patched ROM and soldered the chip back into the calculator. It booted!\nNow, how do we get our new custom machine code into the calculator’s RAM so it can run? Well, back in the day Casio provided software to back up the calculator’s memory. Using this, we can write to RAM!\n\n\n\nA screenshot of the CASIO FA-122 Program-link software. Copyright 1996 but still runs fine on Windows 10.\n\n\nIt turns out that the backup format is essentially just a hex dump of the calculator’s entire RAM, written in ASCII. So, we can add whatever we like by taking a calculator backup, patching the “data record”, then uploading it back to the calculator.\n\n\n\nThe Casio Program-link backup format.\n\n\nI don’t have the correct Program-link cable to plug into the calculator, but that’s nothing a Teensy and 2.5mm jack can’t fix. The calculator communicates with the PC using a serial signal. Here the Teensy is just acting as a RS-232 serial to USB converter.\n\n\n\nA Teensy 2.0 USB development board and a 2.5mm TRS jack that plugs into the bottom of the calculator.\n\n\nWriting code for the calculator was a pain. I didn’t want to work with machine code directly, so writing an assembler was the way to go. David Salomon’s Assemblers And Loaders (1993) book was an incredible help with that.\nI wrote a two-pass assembler in C, using flex and bison for lexing and parsing custom assembly code. The assembler produces what I’ve called an out.bin binary object file, which is similar to Unix’s old a.out format, containing the assembled machine code.\n\n\n\nhcdasm, an assembler for the calculator’s custom CPU.\n\n\nI also wrote a linking loader that takes multiple out.bin formatted files from the assembler, links and relocates the machine code, sets up a specific entry point in the correct place, and finally builds a new RAM image ready to upload to the calculator.\n\n\n\nhcdld, a linking loader that takes assembled objects and builds a RAM image for the calculator containing executable code.\n\n\n\n\n\nFun fact: As far as I can tell, the calculator’s CPU can’t do multiplication by itself. I had to implement my own integer multiplication algorithm in assembly.\n\n\nMy first assembled program running on the actual hardware (that did anything interesting, anyway) was Conway’s Game of Life. This video was taken just after Conway died 😢 I’ve just checked, the source was 263 lines of assembly. It runs so much quicker than Casio BASIC code.\n\nNext I made routines for writing text to screen. I store the data for a 4x6 pixel font in RAM, so that I can fit more characters on screen than in the default OS. At this point everything running is my own code, so it’s a bit like writing an OS from scratch.\n\n\n\n\n“Text rendering” to the calculator’s built in LCD, by writing pixels corresponding to a custom font directly to memory-mapped VRAM.\n\n\n\nAt this point it was time for me to write a RPN interpreter. However, I decided to go a fair step further than that and implement a forth environment for the calculator, which works in RPN style by default. Forth is a wonderful language. You might think C is bare-bones, but it’s got nothing on forth. You can bootstrap up to an entire interactive programming environment by implementing a surprisingly few number of forth primitives in assembly.\nJonesforth is a minimal forth interpreter written in i386 assembly. The source code is written in a literate programming style and is an absolute joy to read from start to finish.\nI ported Jonesforth from i386 to the custom assembly code for the calculator. It came out to about 1000 lines of assembly on top of the display code. Some of the code is stored directly as ASCII in RAM, and compiled by the forth compiler on startup!\n\n\n\nThe point in the source at which enough assembly primitives are in place that we can start just writing Forth code directly.\n\n\nAnd finally, after uploading the assembled forth interpreter to my calculator’s RAM: here is a video showing the result of a calculation that was input using RPN! Apologies for the poor video recording, the calculator screen has dimmed due to age and is extremely hard to film."
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "Automatic assessment of mathematical programming exercises with Numbas\nC. Graham, G. W. Stagg, C. Lawson-Perfect, A. Khan\nMSOR Connections 21, 1 (2023)\nhttps://doi.org/10.21100/msor.v21i1.1395\nA Prolog assisted search for new simple Lie algebras\nD. Cushing, G. W. Stagg, D. I. Stewart\narXiv:2207.01094 [math.RA], (2022)\nhttps://doi.org/10.48550/arXiv.2207.01094\nThe Graph Curvature Calculator and the curvatures of cubic graphs\nD. Cushing, R. Kangaslampi, V. Lipiäinen, S. Liu, G. W. Stagg\nExperimental Mathematics 31, 2 (2022)\nhttps://doi.org/10.1080/10586458.2019.1660740\nQuasiperiodic boundary conditions for three-dimensional superfluids\nToby S. Wood, Mae Mesgarnezhad, George W. Stagg, Carlo F. Barenghi\nPhys. Rev. B 100, 024505 (2019)\nhttps://doi.org/10.1103/PhysRevB.100.024505\nQuantum ferrofluid turbulence\nT. Bland, G. W. Stagg, L. Galantucci, A. W. Baggaley, N. G. Parker\nPhys. Rev. Lett. 121, 174501 (2018)\nhttps://doi.org/10.1103/PhysRevLett.121.174501\nVortex scattering by impurities in a Bose-Einstein condensate\nA. Griffin, G. W. Stagg, N. P. Proukakis and C. F. Barenghi\nJ. Phys. B: At. Mol. Opt. Phys. 50, 115003 (2017)\nhttps://doi.org/10.1088/1361-6455/aa6e97\nSuperfluid boundary layer\nG. W. Stagg, N. G. Parker, C. F. Barenghi\nPhys. Rev. Lett. 118, 0135301 (2017)\nhttps://doi.org/10.1103/PhysRevLett.118.135301\nUltraquantum turbulence in a quenched homogeneous Bose gas\nG. W. Stagg, N. G. Parker, and C. F. Barenghi\nPhys. Rev. A 94, 053632 (2016)\nhttps://doi.org/10.1103/PhysRevA.94.053632\nCritical velocity for vortex nucleation in a finite-temperature Bose gas\nG. W. Stagg, R. W. Pattinson, C. F. Barenghi, N. G. Parker\nPhys. Rev. A 93, 023640 (2016)\nhttps://doi.org/10.1103/PhysRevA.93.023640\nGeneration and Decay of 2D Quantum Turbulence in a Trapped Bose-Einstein Condensate\nG. W. Stagg, A. J. Allen, N. G. Parker, and C. F. Barenghi\nPhys. Rev. A 91, 013612 (2015)\nhttps://doi.org/10.1103/PhysRevA.91.013612\nQuantum analogues of classical wakes in Bose-Einstein condensates\nG. W. Stagg, N. G. Parker and C. F. Barenghi\nJ Phys B: At. Mol. Opt. Phys. 47, 095304 (2014)\nhttps://doi.org/10.1088/0953-4075/47/9/095304"
  },
  {
    "objectID": "publications.html#research-articles",
    "href": "publications.html#research-articles",
    "title": "Publications",
    "section": "",
    "text": "Automatic assessment of mathematical programming exercises with Numbas\nC. Graham, G. W. Stagg, C. Lawson-Perfect, A. Khan\nMSOR Connections 21, 1 (2023)\nhttps://doi.org/10.21100/msor.v21i1.1395\nA Prolog assisted search for new simple Lie algebras\nD. Cushing, G. W. Stagg, D. I. Stewart\narXiv:2207.01094 [math.RA], (2022)\nhttps://doi.org/10.48550/arXiv.2207.01094\nThe Graph Curvature Calculator and the curvatures of cubic graphs\nD. Cushing, R. Kangaslampi, V. Lipiäinen, S. Liu, G. W. Stagg\nExperimental Mathematics 31, 2 (2022)\nhttps://doi.org/10.1080/10586458.2019.1660740\nQuasiperiodic boundary conditions for three-dimensional superfluids\nToby S. Wood, Mae Mesgarnezhad, George W. Stagg, Carlo F. Barenghi\nPhys. Rev. B 100, 024505 (2019)\nhttps://doi.org/10.1103/PhysRevB.100.024505\nQuantum ferrofluid turbulence\nT. Bland, G. W. Stagg, L. Galantucci, A. W. Baggaley, N. G. Parker\nPhys. Rev. Lett. 121, 174501 (2018)\nhttps://doi.org/10.1103/PhysRevLett.121.174501\nVortex scattering by impurities in a Bose-Einstein condensate\nA. Griffin, G. W. Stagg, N. P. Proukakis and C. F. Barenghi\nJ. Phys. B: At. Mol. Opt. Phys. 50, 115003 (2017)\nhttps://doi.org/10.1088/1361-6455/aa6e97\nSuperfluid boundary layer\nG. W. Stagg, N. G. Parker, C. F. Barenghi\nPhys. Rev. Lett. 118, 0135301 (2017)\nhttps://doi.org/10.1103/PhysRevLett.118.135301\nUltraquantum turbulence in a quenched homogeneous Bose gas\nG. W. Stagg, N. G. Parker, and C. F. Barenghi\nPhys. Rev. A 94, 053632 (2016)\nhttps://doi.org/10.1103/PhysRevA.94.053632\nCritical velocity for vortex nucleation in a finite-temperature Bose gas\nG. W. Stagg, R. W. Pattinson, C. F. Barenghi, N. G. Parker\nPhys. Rev. A 93, 023640 (2016)\nhttps://doi.org/10.1103/PhysRevA.93.023640\nGeneration and Decay of 2D Quantum Turbulence in a Trapped Bose-Einstein Condensate\nG. W. Stagg, A. J. Allen, N. G. Parker, and C. F. Barenghi\nPhys. Rev. A 91, 013612 (2015)\nhttps://doi.org/10.1103/PhysRevA.91.013612\nQuantum analogues of classical wakes in Bose-Einstein condensates\nG. W. Stagg, N. G. Parker and C. F. Barenghi\nJ Phys B: At. Mol. Opt. Phys. 47, 095304 (2014)\nhttps://doi.org/10.1088/0953-4075/47/9/095304"
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software & Demos",
    "section": "",
    "text": "WebR\nThe statistical language R compiled into Wasm for use in a browser, via Emscripten.\n GitHub  Website\n\n\n\n\n\n\n\n\nGraph Curvature Calculator\nA web tool for calculating curvature of graphs under various discrete curvature notions.\n GitHub  Website\n\n\n\n\n\n\n\n\n\n2D-GP\nA Fortran project that numerically solves the Gross-Pitaevskii Equation in 2D using OpenMP.\n GitHub\n\n\n\n\n\n\n\n\n3D-GP-MPIOMP\nA Fortran project that numerically solves the Gross-Pitaevskii Equation in 3D using MPI and OpenMP.\n GitHub\n\n\n\n\n\n\n\n\n\nDouble Spherical Pendulum\nClassical physics simulation of a double pendulum with spherical joints and masses otherwise free to move in 3D.\n GitHub  Website\n\n\n\n\n\n\n\n\nWebGL GPE\nA WebGL implementation of a 2D Gross-Pitaevskii Equation numerical solver. The solver runs in real time and is directly interactive.\n GitHub  Website\n\n\n\n\n\n\n\n\n\nHyperbolic Fractals\nDefining the Mandelbrot set on a Poincare disc. Includes an interactive hyperbolic fractal explorer.\n Read Post\n\n\n\n\n\n\n\n\nPrimes!\nTap the tiles to pop out the lowest prime factor. Adjacent primes disappear! Try to clear the board.\n GitHub  Website\n\n\n\n\n\n\n\n\n\nDouble Torus Snake\nSnake, but played on a double torus. An experiment in working with Wasm & Emscripten.\n GitHub  Website\n\n\n\n\n\n\n\n\nTensor Tic Tac Toe\nA meta-game based on Tic Tac Toe. The meta-game is made up of 9 smaller games of Tic Tac Toe.\n GitHub  Website"
  }
]